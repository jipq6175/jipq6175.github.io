<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>SE(3) Score-Matching Diffusion Model | Yen-Lin Chen</title> <meta name="author" content="Yen-Lin Chen"> <meta name="description" content="Approximating ANY SE(3) distributions"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://jipq6175.github.io/blog/2024/se3_diffusion/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Yen-Lin </span>Chen</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blogs<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">SE(3) Score-Matching Diffusion Model</h1> <p class="post-meta">June 27, 2024</p> <p class="post-tags"> <a href="/blog/2024"> <i class="fas fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/coding"> <i class="fas fa-hashtag fa-sm"></i> coding</a>     ·   <a href="/blog/category/models"> <i class="fas fa-tag fa-sm"></i> models</a>   </p> </header> <article class="post-content"> <p>Not all data live in the Euclidean vector space. Respecting underlying symmetries of the data generally limits the model space, allowing more efficient learning and use of the data. In particular, the SE(3) group is important for modeling positions and orientations of systems ranging from protein backbones, rotamers, drones and robot arms.</p> <p>This SE(3) diffusion tutorial aims to build a score-based diffusion generative models for the SE(3) roto-translational data. We will utilize <code class="language-plaintext highlighter-rouge">trimesh</code> and <code class="language-plaintext highlighter-rouge">plotly</code> packages for visualization, <code class="language-plaintext highlighter-rouge">theseus</code> package for SO(3) group operations because of its seamless support on <code class="language-plaintext highlighter-rouge">pytorch</code>’s auto-differentiation.</p> <h3 id="table-of-content">Table of Content</h3> <ol> <li>Lie group, Lie algebra and Vector Space representations</li> <li>Recap on score-based diffusion model with an image example</li> <li>Components for diffusion in SE(3)</li> <li>Train diffusion models for 3 examples</li> </ol> <h3 id="0-libraries-and-helper-functions">0. Libraries and helper functions</h3> <p>Libraries:</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">apt-get <span class="nt">-qq</span> <span class="nb">install </span>libsuitesparse-dev
pip <span class="nb">install</span> <span class="nt">-qq</span> trimesh plotly theseus-ai</code></pre></figure> <p>Helpful functions:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># import the required packages
</span><span class="kn">import</span> <span class="n">torch</span><span class="p">,</span> <span class="n">trimesh</span>

<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="kn">from</span> <span class="n">torch</span> <span class="kn">import</span> <span class="n">nn</span>
<span class="kn">from</span> <span class="n">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="n">trimesh</span> <span class="kn">import</span> <span class="n">viewer</span>
<span class="kn">from</span> <span class="n">IPython</span> <span class="kn">import</span> <span class="n">display</span>
<span class="kn">from</span> <span class="n">torch.autograd</span> <span class="kn">import</span> <span class="n">grad</span>
<span class="kn">from</span> <span class="n">theseus.geometry.so3</span> <span class="kn">import</span> <span class="n">SO3</span>

<span class="kn">import</span> <span class="n">plotly.graph_objects</span> <span class="k">as</span> <span class="n">go</span>
<span class="kn">from</span> <span class="n">plotly.express.colors</span> <span class="kn">import</span> <span class="n">sample_colorscale</span>


<span class="c1"># plot the SO(3) distributions
</span><span class="n">X0</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span> <span class="c1"># using the z axis to show the rotations
</span><span class="k">def</span> <span class="nf">plot_rotations</span><span class="p">(</span><span class="n">rotmats</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">X0</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="sh">'</span><span class="s">jet</span><span class="sh">'</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">Plot the rotation matrices contained in a list: rotmats
    colored coded by the order in the list
    </span><span class="sh">'''</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">rotmats</span><span class="p">))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="nf">sample_colorscale</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="nf">list</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="n">d</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rotmat</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">rotmats</span><span class="p">):</span>
        <span class="n">rotated_x0</span> <span class="o">=</span> <span class="n">rotmat</span> <span class="o">@</span> <span class="n">x0</span>
        <span class="n">d</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">go</span><span class="p">.</span><span class="nc">Scatter3d</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">'</span><span class="p">,</span>
                              <span class="n">x</span><span class="o">=</span><span class="n">rotated_x0</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                              <span class="n">y</span><span class="o">=</span><span class="n">rotated_x0</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                              <span class="n">z</span><span class="o">=</span><span class="n">rotated_x0</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                              <span class="n">marker</span><span class="o">=</span><span class="nf">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">opacity</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">mode</span><span class="o">=</span><span class="sh">'</span><span class="s">markers</span><span class="sh">'</span><span class="p">,</span> <span class="p">))</span>

    <span class="n">d</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">go</span><span class="p">.</span><span class="nc">Scatter3d</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sh">'</span><span class="s">x0</span><span class="sh">'</span><span class="p">,</span>
                          <span class="n">x</span><span class="o">=</span><span class="n">x0</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span>
                          <span class="n">y</span><span class="o">=</span><span class="n">x0</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span>
                          <span class="n">z</span><span class="o">=</span><span class="n">x0</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span>
                          <span class="n">marker</span><span class="o">=</span><span class="nf">dict</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">opacity</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="sh">'</span><span class="s">markers</span><span class="sh">'</span><span class="p">))</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="p">.</span><span class="nc">Figure</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">.</span><span class="nf">update_layout</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">800</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">None</span>


<span class="c1"># visualize the angle and positions of SE(3) as robot grasps or forks
</span><span class="k">def</span> <span class="nf">create_gripper_marker</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">],</span> <span class="n">tube_radius</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">sections</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">Create a 3D mesh visualizing a parallel yaw gripper. It consists of four cylinders.

    Args:
        color (list, optional): RGB values of marker. Defaults to [0, 0, 255].
        tube_radius (float, optional): Radius of cylinders. Defaults to 0.001.
        sections (int, optional): Number of sections of each cylinder. Defaults to 6.

    Returns:
        trimesh.Trimesh: A mesh that represents a simple parallel yaw gripper.
    </span><span class="sh">"""</span>
    <span class="n">cfl</span> <span class="o">=</span> <span class="n">trimesh</span><span class="p">.</span><span class="n">creation</span><span class="p">.</span><span class="nf">cylinder</span><span class="p">(</span>
        <span class="n">radius</span><span class="o">=</span><span class="mf">0.002</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">sections</span><span class="o">=</span><span class="n">sections</span><span class="p">,</span>
        <span class="n">segment</span><span class="o">=</span><span class="p">[</span>
            <span class="p">[</span><span class="mf">4.10000000e-02</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="o">-</span><span class="mf">7.27595772e-12</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="mf">6.59999996e-02</span><span class="o">*</span><span class="n">scale</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">4.10000000e-02</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="o">-</span><span class="mf">7.27595772e-12</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="mf">1.12169998e-01</span><span class="o">*</span><span class="n">scale</span><span class="p">],</span>
        <span class="p">],</span>
    <span class="p">)</span>
    <span class="n">cfr</span> <span class="o">=</span> <span class="n">trimesh</span><span class="p">.</span><span class="n">creation</span><span class="p">.</span><span class="nf">cylinder</span><span class="p">(</span>
        <span class="n">radius</span><span class="o">=</span><span class="mf">0.002</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">sections</span><span class="o">=</span><span class="n">sections</span><span class="p">,</span>
        <span class="n">segment</span><span class="o">=</span><span class="p">[</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">4.100000e-02</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="o">-</span><span class="mf">7.27595772e-12</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="mf">6.59999996e-02</span><span class="o">*</span><span class="n">scale</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">4.100000e-02</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="o">-</span><span class="mf">7.27595772e-12</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="mf">1.12169998e-01</span><span class="o">*</span><span class="n">scale</span><span class="p">],</span>
        <span class="p">],</span>
    <span class="p">)</span>
    <span class="n">cb1</span> <span class="o">=</span> <span class="n">trimesh</span><span class="p">.</span><span class="n">creation</span><span class="p">.</span><span class="nf">cylinder</span><span class="p">(</span>
        <span class="n">radius</span><span class="o">=</span><span class="mf">0.002</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="n">sections</span><span class="o">=</span><span class="n">sections</span><span class="p">,</span> <span class="n">segment</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">6.59999996e-02</span><span class="o">*</span><span class="n">scale</span><span class="p">]]</span>
    <span class="p">)</span>
    <span class="n">cb2</span> <span class="o">=</span> <span class="n">trimesh</span><span class="p">.</span><span class="n">creation</span><span class="p">.</span><span class="nf">cylinder</span><span class="p">(</span>
        <span class="n">radius</span><span class="o">=</span><span class="mf">0.002</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span>
        <span class="n">sections</span><span class="o">=</span><span class="n">sections</span><span class="p">,</span>
        <span class="n">segment</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mf">4.100000e-02</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">6.59999996e-02</span><span class="o">*</span><span class="n">scale</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.100000e-02</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">6.59999996e-02</span><span class="o">*</span><span class="n">scale</span><span class="p">]],</span>
    <span class="p">)</span>

    <span class="n">tmp</span> <span class="o">=</span> <span class="n">trimesh</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">([</span><span class="n">cb1</span><span class="p">,</span> <span class="n">cb2</span><span class="p">,</span> <span class="n">cfr</span><span class="p">,</span> <span class="n">cfl</span><span class="p">])</span>
    <span class="n">tmp</span><span class="p">.</span><span class="n">visual</span><span class="p">.</span><span class="n">face_colors</span> <span class="o">=</span> <span class="n">color</span>
    <span class="n">tmp</span><span class="p">.</span><span class="n">visual</span><span class="p">.</span><span class="n">vertex_colors</span> <span class="o">=</span> <span class="n">color</span>

    <span class="k">return</span> <span class="n">tmp</span>

<span class="c1"># Visualize a set of SE(3) elements H (..., 4, 4)
# by creating forks for each fork from the above function
</span><span class="k">def</span> <span class="nf">visualize_grasps</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">p_cloud</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">energies</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>

    <span class="c1"># Set color list
</span>    <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">energies</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">Hs</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">min_energy</span> <span class="o">=</span> <span class="n">energies</span><span class="p">.</span><span class="nf">min</span><span class="p">()</span>
            <span class="n">energies</span> <span class="o">-=</span><span class="n">min_energy</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">energies</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">energies</span><span class="p">)</span><span class="o">+</span><span class="mf">1e-6</span><span class="p">)</span>

    <span class="c1"># Grips
</span>    <span class="n">grips</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">Hs</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">Hs</span><span class="p">[</span><span class="n">k</span><span class="p">,...]</span>

        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">color</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">c_vis</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">int</span><span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="mi">254</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">c_vis</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">k</span><span class="p">,...]))</span>

        <span class="n">grips</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span>
            <span class="nf">create_gripper_marker</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">c_vis</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">).</span><span class="nf">apply_transform</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Visualize grips and the object
</span>    <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">scene</span> <span class="o">=</span> <span class="n">trimesh</span><span class="p">.</span><span class="nc">Scene</span><span class="p">([</span><span class="n">mesh</span><span class="p">]</span><span class="o">+</span> <span class="n">grips</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">p_cloud</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">p_cloud_tri</span> <span class="o">=</span> <span class="n">trimesh</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="nc">PointCloud</span><span class="p">(</span><span class="n">p_cloud</span><span class="p">)</span>
        <span class="n">scene</span> <span class="o">=</span> <span class="n">trimesh</span><span class="p">.</span><span class="nc">Scene</span><span class="p">([</span><span class="n">p_cloud_tri</span><span class="p">]</span><span class="o">+</span> <span class="n">grips</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">scene</span> <span class="o">=</span> <span class="n">trimesh</span><span class="p">.</span><span class="nc">Scene</span><span class="p">(</span><span class="n">grips</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scene</span></code></pre></figure> <h3 id="1-lie-group-lie-algebra-and-vector-space-representations-for-so3">1. Lie Group, Lie Algebra and Vector space representations for SO(3)</h3> <p>In this section, we will explore the SO(3) group using the following operations. The figures are from <a href="https://arxiv.org/pdf/1812.01537" rel="external nofollow noopener" target="_blank">A micro Lie theory for state estimation in robotics</a>.</p> <p><img title="" alt="Alt text" src="https://d3i71xaburhd42.cloudfront.net/3a75252bab18250b8de8be28ec376db6cfc04084/4-TableI-1.png"></p> <p>Here is a more visual or conceptual conversions.</p> <p><img title="" alt="Alt text" src="https://d3i71xaburhd42.cloudfront.net/3a75252bab18250b8de8be28ec376db6cfc04084/5-Figure5-1.png"></p> <p>For SO(3), group elements are 3x3 rotation matrices on the right, belonging to the manifold.</p> <p>For the Lie Algebra and axis-angle representations are vectors (or can be represented as vectors) on the left, belonging to the tangent space at Identity.</p> <ul> <li> <p>The <code class="language-plaintext highlighter-rouge">exp</code> and <code class="language-plaintext highlighter-rouge">log</code> are algebric operations that convert from SO(3) to so(3).</p> </li> <li> <p>The <code class="language-plaintext highlighter-rouge">vee</code> and <code class="language-plaintext highlighter-rouge">hat</code> are trivial operations, extracting or constructing between axis-angle vector to skew-symmetric matrices.</p> </li> <li> <p>The <code class="language-plaintext highlighter-rouge">Exp</code> and <code class="language-plaintext highlighter-rouge">Log</code> are shortcut transformations that conveniently map between SO(3) to axis-angle vectors.</p> </li> </ul> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">torch</span><span class="p">.</span><span class="nf">manual_seed</span><span class="p">(</span><span class="mi">37</span><span class="p">)</span>
<span class="n">ATOL</span><span class="p">,</span> <span class="n">RTOL</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-5</span>

<span class="c1"># Dummy rotations for visualization of a sphere
</span><span class="n">R_dummy</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">exp_map</span><span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">3</span><span class="p">)).</span><span class="nf">to_matrix</span><span class="p">()</span>

<span class="c1"># v or v_vee is the axis-angle vector representation, in R^3
# v_hat is the lie algebra, in so(3) or skew symmetric matrix
# R is the 3D rotation matrix, in SO(3)
</span>
<span class="c1"># initialize vector or axis angle representation
</span><span class="n">v1</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1"># rotation matrices from Exp
</span><span class="n">R1</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">exp_map</span><span class="p">(</span><span class="n">v1</span><span class="p">).</span><span class="nf">to_matrix</span><span class="p">()</span>
<span class="n">R2</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">exp_map</span><span class="p">(</span><span class="n">v2</span><span class="p">).</span><span class="nf">to_matrix</span><span class="p">()</span>

<span class="c1"># skew symmetric matrix in so(3)
</span><span class="n">v1_hat</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">hat</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
<span class="n">v2_hat</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">hat</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Example of the so3 skew symmetric matrix:</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">v1_hat</span><span class="p">)</span>


<span class="c1"># check the consistency between vector and rotation
# 1 + 2 cos(theta) = trace(R), where theta is the length of the vector
</span><span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">v1</span><span class="p">.</span><span class="nf">norm</span><span class="p">()),</span>
                      <span class="n">torch</span><span class="p">.</span><span class="nf">diagonal</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">dim1</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim2</span><span class="o">=-</span><span class="mi">2</span><span class="p">).</span><span class="nf">sum</span><span class="p">(),</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">v2</span><span class="p">.</span><span class="nf">norm</span><span class="p">()),</span>
                      <span class="n">torch</span><span class="p">.</span><span class="nf">diagonal</span><span class="p">(</span><span class="n">R2</span><span class="p">,</span> <span class="n">dim1</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim2</span><span class="o">=-</span><span class="mi">2</span><span class="p">).</span><span class="nf">sum</span><span class="p">(),</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">)</span>


<span class="c1"># 1. check the vee operator
</span><span class="n">v1_vee</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">vee</span><span class="p">(</span><span class="n">v1_hat</span><span class="p">)</span>
<span class="n">v2_vee</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">vee</span><span class="p">(</span><span class="n">v2_hat</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v1_vee</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v2_vee</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>

<span class="c1"># 2. the lowercase exp is the matrix exponential from so3 to SO3
</span><span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matrix_exp</span><span class="p">(</span><span class="n">v1_hat</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">R2</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matrix_exp</span><span class="p">(</span><span class="n">v2_hat</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>

<span class="c1"># 3. the exp_map is the uppercase Exp, from R^3 to SO3
#    we used the SO3().exp_map previously but let's check
#    Exp[.] = exp( hat(.) )
</span><span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matrix_exp</span><span class="p">(</span><span class="nc">SO3</span><span class="p">().</span><span class="nf">hat</span><span class="p">(</span><span class="n">v1</span><span class="p">)),</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">R2</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">matrix_exp</span><span class="p">(</span><span class="nc">SO3</span><span class="p">().</span><span class="nf">hat</span><span class="p">(</span><span class="n">v2</span><span class="p">)),</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>

<span class="c1"># 4. the log_map is the uppercase Log_map from SO(3) to R^3
</span><span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="nc">SO3</span><span class="p">(</span><span class="n">tensor</span><span class="o">=</span><span class="n">R1</span><span class="p">).</span><span class="nf">log_map</span><span class="p">(),</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="nc">SO3</span><span class="p">(</span><span class="n">tensor</span><span class="o">=</span><span class="n">R2</span><span class="p">).</span><span class="nf">log_map</span><span class="p">(),</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>

<span class="c1"># 5. the log operation: log R = v_hat = theta * (R - R^T) / (2 sin(theta))
</span><span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">v1_hat</span><span class="p">,</span> <span class="n">v1</span><span class="p">.</span><span class="nf">norm</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">R1</span> <span class="o">-</span> <span class="n">R1</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">/</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">v1</span><span class="p">.</span><span class="nf">norm</span><span class="p">()),</span>
                      <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">v2_hat</span><span class="p">,</span> <span class="n">v2</span><span class="p">.</span><span class="nf">norm</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">R2</span> <span class="o">-</span> <span class="n">R2</span><span class="p">.</span><span class="nf">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">/</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">v2</span><span class="p">.</span><span class="nf">norm</span><span class="p">()),</span>
                      <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>

<span class="c1"># Outputs: 
# Example of the so3 skew symmetric matrix:
# tensor([[[ 0.0000, -0.5821,  1.2653],
#          [ 0.5821,  0.0000, -0.7207],
#          [-1.2653,  0.7207,  0.0000]]])</span></code></pre></figure> <p>Next, we will define and check operations in the SO(3) group.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># Operation for the SO(3) group
</span>
<span class="c1"># 1. hat(v1 + v2) = hat(v1) + hat(v2)
#    because v and v_hat are in the same vector space
</span><span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">v1_hat</span> <span class="o">+</span> <span class="n">v2_hat</span><span class="p">,</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">hat</span><span class="p">(</span><span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>


<span class="c1"># 2. compose the rotation by right multiplication
</span><span class="n">R3</span> <span class="o">=</span> <span class="n">R1</span> <span class="o">@</span> <span class="n">R2</span>
<span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">R3</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">einsum</span><span class="p">(</span><span class="sh">'</span><span class="s">...ij,...jk-&gt;...ik</span><span class="sh">'</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>



<span class="c1"># 3. compose the vector:
#    The rotation composition is not commutative, i.e. R1 @ R2 != R2 @ R1
#    so apparently, Exp_map(v1 + v2) != R1 @ R2.
#    The reason is that the geodesic of Exp_map(v1) is different from geodesic of Exp_map(v2)
#    To get the vector representation from v1 and v2, we will need to
#    - compose the corresponding rotations
#    - transform it back by taking the Log_map
</span><span class="k">def</span> <span class="nf">compose_rotvec</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
  <span class="n">R1</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">exp_map</span><span class="p">(</span><span class="n">v1</span><span class="p">).</span><span class="nf">to_matrix</span><span class="p">()</span>
  <span class="n">R2</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">exp_map</span><span class="p">(</span><span class="n">v2</span><span class="p">).</span><span class="nf">to_matrix</span><span class="p">()</span>
  <span class="n">R3</span> <span class="o">=</span> <span class="n">R1</span> <span class="o">@</span> <span class="n">R2</span>
  <span class="k">return</span> <span class="nc">SO3</span><span class="p">(</span><span class="n">tensor</span><span class="o">=</span><span class="n">R3</span><span class="p">).</span><span class="nf">log_map</span><span class="p">()</span>

<span class="n">v3_a</span> <span class="o">=</span> <span class="nf">compose_rotvec</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
<span class="n">v3_b</span> <span class="o">=</span> <span class="nf">compose_rotvec</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>

<span class="k">assert</span> <span class="ow">not</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">v3_a</span><span class="p">,</span> <span class="n">v3_b</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">R1</span> <span class="o">@</span> <span class="n">R2</span><span class="p">,</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">exp_map</span><span class="p">(</span><span class="n">v3_a</span><span class="p">).</span><span class="nf">to_matrix</span><span class="p">(),</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">R2</span> <span class="o">@</span> <span class="n">R1</span><span class="p">,</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">exp_map</span><span class="p">(</span><span class="n">v3_b</span><span class="p">).</span><span class="nf">to_matrix</span><span class="p">(),</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>



<span class="c1"># 4. Interpolations between two rotations on the SO3 geodesic
#    See: https://en.wikipedia.org/wiki/Slerp
</span><span class="k">def</span> <span class="nf">slerp</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">R1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">R2</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">weights</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="nf">assert </span><span class="p">(</span><span class="n">weights</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">).</span><span class="nf">any</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">weights</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">).</span><span class="nf">any</span><span class="p">()</span>

  <span class="n">R1_norm</span> <span class="o">=</span> <span class="n">R1</span> <span class="o">/</span> <span class="n">torch</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
  <span class="n">R2_norm</span> <span class="o">=</span> <span class="n">R2</span> <span class="o">/</span> <span class="n">torch</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">R2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
  <span class="n">omega</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">acos</span><span class="p">((</span><span class="n">R1_norm</span> <span class="o">*</span> <span class="n">R2_norm</span><span class="p">).</span><span class="nf">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
  <span class="n">so</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">sin</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">weights</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">])</span> <span class="o">*</span> <span class="n">omega</span><span class="p">)</span> <span class="o">/</span> <span class="n">so</span><span class="p">).</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">R1</span> <span class="o">+</span> <span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">weights</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">omega</span><span class="p">)</span> <span class="o">/</span> <span class="n">so</span><span class="p">).</span><span class="nf">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">R2</span>
  <span class="k">return</span> <span class="n">res</span>

<span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="nf">slerp</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">])),</span> <span class="n">R2</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="nf">slerp</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="mf">0.0</span><span class="p">])),</span> <span class="n">R1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>

<span class="n">torch</span><span class="p">.</span><span class="nf">manual_seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="nf">slerp</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="nf">slerp</span><span class="p">(</span><span class="n">R2</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">w</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>



<span class="c1"># 5. "Scale" a rotation by geodesic interpolation
#    Scaling operator can be done with a weighted interpolation between identity and the rotation
#    0 &lt;= scale &lt;= 1
</span><span class="k">def</span> <span class="nf">scale_rotations</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
  <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
  <span class="k">assert</span> <span class="n">R</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">scale</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="nf">assert </span><span class="p">(</span><span class="n">scale</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">).</span><span class="nf">any</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">).</span><span class="nf">any</span><span class="p">()</span>
  <span class="n">batch</span> <span class="o">=</span> <span class="n">R</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">return</span> <span class="nf">slerp</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)[</span><span class="bp">None</span><span class="p">,</span> <span class="p">...].</span><span class="nf">repeat</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">R</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span> <span class="c1"># just use SLERP
</span>
<span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="nf">scale_rotations</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="nf">allclose</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)[</span><span class="bp">None</span><span class="p">,</span> <span class="p">...],</span> <span class="nf">scale_rotations</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span> <span class="n">atol</span><span class="o">=</span><span class="n">ATOL</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">RTOL</span><span class="p">)</span>


<span class="c1"># 5. "Scale" a rotation by scaling the angle while fixing the axis
#    Scaling a rotation by 0 = Identity (zero degree)
#    Scaling a rotation by 0.5 = rotate (0.5 * theta) wrt the same axis
#    Scaling a rotation by 1.0 = the same ratation
#    Therefore, again, 0 &lt;= scale &lt;= 1
</span><span class="k">def</span> <span class="nf">scale_rotations_by_angle</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
  <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
  <span class="k">assert</span> <span class="n">R</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">scale</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="nf">assert </span><span class="p">(</span><span class="n">scale</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">).</span><span class="nf">any</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">scale</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">).</span><span class="nf">any</span><span class="p">()</span>

  <span class="n">v</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">(</span><span class="n">tensor</span><span class="o">=</span><span class="n">R</span><span class="p">).</span><span class="nf">log_map</span><span class="p">()</span> <span class="c1"># convert from R to v
</span>  <span class="n">scaled_v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">scale</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">]</span> <span class="c1"># scale v, changing the theta while keeping the axis the same
</span>  <span class="k">return</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">exp_map</span><span class="p">(</span><span class="n">scaled_v</span><span class="p">).</span><span class="nf">to_matrix</span><span class="p">()</span> <span class="c1"># convert it back to the rotation matrix by Exp
</span>

<span class="c1"># 6. Visualizing scaled rotations and interpolated rotations
</span><span class="n">n_scale</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">scales</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_scale</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># scaling
</span><span class="n">rots</span> <span class="o">=</span> <span class="p">[</span><span class="nf">scale_rotations</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="n">scale</span><span class="p">]))</span> <span class="k">for</span> <span class="n">scale</span> <span class="ow">in</span> <span class="n">scales</span><span class="p">]</span>
<span class="nf">plot_rotations</span><span class="p">([</span><span class="n">R_dummy</span><span class="p">]</span> <span class="o">+</span> <span class="n">rots</span><span class="p">)</span>

<span class="c1"># interpolating R1 -&gt; R2
</span><span class="n">rots</span> <span class="o">=</span> <span class="p">[</span><span class="nf">slerp</span><span class="p">(</span><span class="n">R1</span><span class="p">,</span> <span class="n">R2</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="n">scale</span><span class="p">]))</span> <span class="k">for</span> <span class="n">scale</span> <span class="ow">in</span> <span class="n">scales</span><span class="p">]</span>
<span class="nf">plot_rotations</span><span class="p">([</span><span class="n">R_dummy</span><span class="p">]</span> <span class="o">+</span> <span class="n">rots</span><span class="p">)</span>

<span class="c1"># interpolating R2 -&gt; R1
</span><span class="n">rots</span> <span class="o">=</span> <span class="p">[</span><span class="nf">slerp</span><span class="p">(</span><span class="n">R2</span><span class="p">,</span> <span class="n">R1</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="n">scale</span><span class="p">]))</span> <span class="k">for</span> <span class="n">scale</span> <span class="ow">in</span> <span class="n">scales</span><span class="p">]</span>
<span class="nf">plot_rotations</span><span class="p">([</span><span class="n">R_dummy</span><span class="p">]</span> <span class="o">+</span> <span class="n">rots</span><span class="p">)</span></code></pre></figure> <iframe src="/assets/img/posts/se3diff/scaling.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <p>The scaling is from 0.0 to 1.0, corresponding to an interpolation on the sphere from <code class="language-plaintext highlighter-rouge">I</code> to <code class="language-plaintext highlighter-rouge">R</code> (blue to red).</p> <p>The interpolations between <code class="language-plaintext highlighter-rouge">R1</code> and <code class="language-plaintext highlighter-rouge">R2</code> are as follows:</p> <iframe src="/assets/img/posts/se3diff/r1_r2_interp.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <iframe src="/assets/img/posts/se3diff/r2_r1_interp.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <p>The trajectories are the same but flipped in direction.</p> <h3 id="2-recap-on-score-based-generative-models">2. Recap on Score-based generative models</h3> <p>Given a ground truth \(x(0)\) and some data at time t \(x(t) \sim p_t \sim N(m(t)x(0), v(t)I)\), we can compute the score, or</p> \[\nabla_{x(t)}\log p_t = -\frac{x(t)-m(t)x(0)}{v(t)}\] <p>In many of the score-matching models, the problem was designing \(m(t)\) and \(v(t)\). Here just for the demo of the score concept, we chose \(m(t) = 1\) and linear scheduling for the variance \(v(t)\).</p> <p>We will use the Langevin dynamics for generation or sampling:</p> \[x(t+dt) = x(t) + [\nabla_{x(t)}\log p_t]dt + \sqrt{2dt}z\] <p>where \(z\sim N(0, I)\).</p> <ul> <li>The annealed Langevin dynamics corresponds to varying \(v(t)\)</li> <li>The ODE-like sampling is the process where \(z=0\). Note that this is not the ODE-flow that aims to approximate the NLL of the data.</li> </ul> <p>Some researches used SDE to design the mean and variance because there are exact form other than Langevin dynamics when we are doing the generation, which some nice properties might arise. This is out of the scope of this notebook.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="n">requests</span>
<span class="kn">from</span> <span class="n">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="n">torchvision.transforms</span> <span class="kn">import</span> <span class="n">Compose</span><span class="p">,</span> <span class="n">ToTensor</span><span class="p">,</span> <span class="n">Lambda</span><span class="p">,</span> <span class="n">ToPILImage</span><span class="p">,</span> <span class="n">CenterCrop</span><span class="p">,</span> <span class="n">Resize</span>

<span class="n">url</span> <span class="o">=</span> <span class="sh">'</span><span class="s">http://images.cocodataset.org/val2017/000000039769.jpg</span><span class="sh">'</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">requests</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="bp">True</span><span class="p">).</span><span class="n">raw</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Original Image size = </span><span class="sh">'</span><span class="p">,</span> <span class="nc">ToTensor</span><span class="p">()(</span><span class="n">image</span><span class="p">).</span><span class="n">shape</span><span class="p">)</span>

<span class="n">image_size</span> <span class="o">=</span> <span class="mi">128</span>

<span class="c1"># a series of transformations
</span><span class="n">transform</span> <span class="o">=</span> <span class="nc">Compose</span><span class="p">([</span><span class="nc">Resize</span><span class="p">(</span><span class="n">image_size</span><span class="p">),</span>
                     <span class="nc">CenterCrop</span><span class="p">(</span><span class="n">image_size</span><span class="p">),</span>
                     <span class="nc">ToTensor</span><span class="p">(),</span> <span class="c1"># turn into torch tensor of shape (Height x Width x Channel), divide by 255 in RGB
</span>                     <span class="nc">Lambda</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span>

<span class="c1"># inverse transform
</span><span class="n">reverse_transform</span> <span class="o">=</span> <span class="nc">Compose</span><span class="p">([</span><span class="nc">Lambda</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
                             <span class="nc">Lambda</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">.</span><span class="nf">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="c1"># C x H x W to H x W x C
</span>                             <span class="nc">Lambda</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span> <span class="o">*</span> <span class="mf">255.0</span><span class="p">),</span>
                             <span class="nc">Lambda</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">.</span><span class="nf">numpy</span><span class="p">().</span><span class="nf">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">uint8</span><span class="p">)),</span>
                             <span class="nc">ToPILImage</span><span class="p">()])</span>

<span class="n">x_start</span> <span class="o">=</span> <span class="nf">transform</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">New Image Size = </span><span class="sh">'</span><span class="p">,</span> <span class="n">x_start</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">x_start</span> <span class="o">=</span> <span class="n">x_start</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">...]</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Batched New Image Size = </span><span class="sh">'</span><span class="p">,</span> <span class="n">x_start</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>

<span class="nf">reverse_transform</span><span class="p">(</span><span class="n">x_start</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># 2 sleeping cats : )
</span>
<span class="c1"># Outputs:
# Original Image size =  torch.Size([3, 480, 640])
# New Image Size =  torch.Size([3, 128, 128])
# Batched New Image Size =  torch.Size([1, 3, 128, 128])</span></code></pre></figure> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/se3diff/original-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/se3diff/original-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/se3diff/original-1400.webp"></source> <img src="/assets/img/posts/se3diff/original.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># compute the scores
# here because we have access to the single ground truth, we can calculate it directly
# But in the ML problem, we want a NN to learn this
# Note that the function or model inputs are noised_x and time (or std) (we won't have ground truth during sampling)
# and output is an image of vector fields or the score
</span><span class="k">def</span> <span class="nf">compute_score_image</span><span class="p">(</span><span class="n">x_noised</span><span class="p">,</span> <span class="n">x_truth</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">x_noised</span><span class="p">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">x_truth</span><span class="p">.</span><span class="n">shape</span>
  <span class="k">assert</span> <span class="n">x_noised</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">std</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_noised</span> <span class="o">-</span> <span class="n">x_truth</span><span class="p">)</span> <span class="c1"># (b, c, w, h)
</span>  <span class="k">return</span> <span class="o">-</span> <span class="n">dist</span> <span class="o">/</span> <span class="p">(</span><span class="n">std</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>


<span class="c1"># following the score back to the sample using Langevin dynamics
# noise_on = False: ODE-like or noise-free
# std_min = std_max: unannealed
</span><span class="k">def</span> <span class="nf">follow_score_image</span><span class="p">(</span><span class="n">x_truth</span><span class="p">,</span> <span class="n">std_min</span><span class="p">,</span> <span class="n">std_max</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">1500</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1001</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">std_min</span> <span class="o">&lt;=</span> <span class="n">std_max</span>
  <span class="n">std</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="n">std_max</span><span class="p">,</span> <span class="n">std_min</span><span class="p">,</span> <span class="n">T</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

  <span class="n">torch</span><span class="p">.</span><span class="nf">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
  <span class="n">x_noised</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn_like</span><span class="p">(</span><span class="n">x_truth</span><span class="p">)</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">x_noised</span><span class="p">.</span><span class="nf">clone</span><span class="p">()</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">T</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">score</span> <span class="o">=</span> <span class="nf">compute_score_image</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_truth</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="n">std</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span> <span class="c1"># this will be where the NN model comes in
</span>    <span class="n">x</span> <span class="o">+=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">score</span>
    <span class="k">if</span> <span class="n">noise_on</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">T</span><span class="p">:</span>
      <span class="n">x</span> <span class="o">+=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">x</span>


<span class="c1"># some visualizations
</span><span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Un-annealed ODE-like</span><span class="sh">'</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="nf">follow_score_image</span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="nf">reverse_transform</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Annealed ODE-like</span><span class="sh">'</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="nf">follow_score_image</span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="nf">reverse_transform</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Un-annealed Langevin dynamics</span><span class="sh">'</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="nf">follow_score_image</span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="nf">reverse_transform</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Annealed Langevin dynamics</span><span class="sh">'</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="nf">follow_score_image</span><span class="p">(</span><span class="n">x_start</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="nf">reverse_transform</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Note: this just a demo and does not suggest which sampling is superior</span><span class="sh">'</span><span class="p">)</span></code></pre></figure> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/se3diff/o1-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/se3diff/o1-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/se3diff/o1-1400.webp"></source> <img src="/assets/img/posts/se3diff/o1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/se3diff/o2-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/se3diff/o2-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/se3diff/o2-1400.webp"></source> <img src="/assets/img/posts/se3diff/o2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/se3diff/o3-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/se3diff/o3-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/se3diff/o3-1400.webp"></source> <img src="/assets/img/posts/se3diff/o3.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/se3diff/o4-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/se3diff/o4-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/se3diff/o4-1400.webp"></source> <img src="/assets/img/posts/se3diff/o4.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>In the figures above from left to right, they are generated from Un-annealed ODE-like, Annealed ODE-like, Un-annealed Langevin dynamics and Annealed Langevin dynamics.</p> <p>Note: this just a demo and does not suggest which sampling is superior.</p> <h3 id="3-critical-components-for-score-based-diffusion-in-se3">3. Critical components for score-based diffusion in SE(3)</h3> <p>In the previous example, we use a (ground truth) score model <code class="language-plaintext highlighter-rouge">compute_score_image</code> to generate (the same) images by following the score. This example implies that if we want to generalize score-matching diffusion model, we need to define the following on SO(3):</p> <ol> <li>Scale, <code class="language-plaintext highlighter-rouge">scale_rotations</code> </li> <li>Add, composition of rotations, <code class="language-plaintext highlighter-rouge">R1 @ R2</code> or <code class="language-plaintext highlighter-rouge">compose_rotvec(v1, v2)</code> </li> <li>Gaussian. IGSO3</li> </ol> <p>Further, it also depends on the representation we are working on. We will working with the vector or axis-angle representation for rotation in SO(3) and translation vector in \(R^3\). Together, we have a 6-degree-of-freedom representation for SE(3) data. T</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># Sampling from a SE-3 Gaussian Distribution
</span><span class="k">def</span> <span class="nf">sample_from_se3_gaussian</span><span class="p">(</span><span class="n">x_tar</span><span class="p">,</span> <span class="n">R_tar</span><span class="p">,</span> <span class="n">std</span><span class="p">):</span>
  <span class="sh">'''</span><span class="s">
  x_tar: translational mean, (..., 3)
  R_tar: rotational mean, (..., 3, 3)
  std: standard deviation, (..., )
  </span><span class="sh">'''</span>

  <span class="n">x_eps</span> <span class="o">=</span> <span class="n">std</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn_like</span><span class="p">(</span><span class="n">x_tar</span><span class="p">)</span>

  <span class="n">theta_eps</span> <span class="o">=</span> <span class="n">std</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn_like</span><span class="p">(</span><span class="n">x_tar</span><span class="p">)</span>
  <span class="n">rot_eps</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">exp_map</span><span class="p">(</span><span class="n">theta_eps</span><span class="p">).</span><span class="nf">to_matrix</span><span class="p">()</span>

  <span class="n">_x</span> <span class="o">=</span> <span class="n">x_tar</span> <span class="o">+</span> <span class="n">x_eps</span> <span class="c1"># compose the translation
</span>  <span class="n">_R</span> <span class="o">=</span> <span class="n">R_tar</span> <span class="o">@</span> <span class="n">rot_eps</span> <span class="c1"># compose the rotation by matrix mutiplication
</span>  <span class="k">return</span> <span class="n">_x</span><span class="p">,</span> <span class="n">_R</span>


<span class="c1"># another implementation using theseus built-in randn
</span><span class="k">def</span> <span class="nf">sample_from_se3_gaussian_with_theseus</span><span class="p">(</span><span class="n">x_tar</span><span class="p">,</span> <span class="n">R_tar</span><span class="p">,</span> <span class="n">std</span><span class="p">):</span>
  <span class="sh">'''</span><span class="s">
  x_tar: translational mean, (..., 3)
  R_tar: rotational mean, (..., 3, 3)
  std: standard deviation, (..., )
  </span><span class="sh">'''</span>
  <span class="n">batch_size</span> <span class="o">=</span> <span class="n">std</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">x_eps</span> <span class="o">=</span> <span class="n">std</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn_like</span><span class="p">(</span><span class="n">x_tar</span><span class="p">)</span>
  <span class="n">rot_eps</span> <span class="o">=</span> <span class="nf">scale_rotations</span><span class="p">(</span><span class="n">SO3</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">).</span><span class="nf">to_matrix</span><span class="p">(),</span> <span class="n">std</span><span class="p">)</span>

  <span class="n">_x</span> <span class="o">=</span> <span class="n">x_tar</span> <span class="o">+</span> <span class="n">x_eps</span> <span class="c1"># compose the translation
</span>  <span class="n">_R</span> <span class="o">=</span> <span class="n">R_tar</span> <span class="o">@</span> <span class="n">rot_eps</span> <span class="c1"># compose the rotation
</span>  <span class="k">return</span> <span class="n">_x</span><span class="p">,</span> <span class="n">_R</span>


<span class="c1"># using the complicated formula of IGSO3
</span>

<span class="c1"># A helper function construct H from x and R
# H = [[R, x],
#      [0, 1]]
</span><span class="k">def</span> <span class="nf">construct_roto_trans</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
  <span class="k">assert</span> <span class="nf">len</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
  <span class="k">assert</span> <span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">R</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">batch_size</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="n">H</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)[</span><span class="bp">None</span><span class="p">,</span> <span class="p">...].</span><span class="nf">repeat</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">H</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="p">.</span><span class="nf">clone</span><span class="p">()</span>
  <span class="n">H</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">clone</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">H</span></code></pre></figure> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">torch</span><span class="p">.</span><span class="nf">manual_seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="mi">400</span>
<span class="n">R_mu</span> <span class="o">=</span> <span class="n">SO3</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">to_matrix</span><span class="p">().</span><span class="nf">repeat</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># mean rotation
</span><span class="n">x_mu</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">).</span><span class="nf">repeat</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># mean translation
</span>
<span class="c1"># rotation and translation combined in the H tensor (..., 4, 4)
</span><span class="n">H_mu</span> <span class="o">=</span> <span class="nf">construct_roto_trans</span><span class="p">(</span><span class="n">x_mu</span><span class="p">,</span> <span class="n">R_mu</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">An example of SE(3) group element:</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">H_mu</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># Visualizations of Gaussians on SO(3) centering at mean rotation with different std
</span><span class="n">stds</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">]</span>
<span class="n">rots</span><span class="p">,</span> <span class="n">rots_with_theseus</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">std</span> <span class="ow">in</span> <span class="n">stds</span><span class="p">:</span>

  <span class="n">__</span><span class="p">,</span> <span class="n">R_samples</span> <span class="o">=</span> <span class="nf">sample_from_se3_gaussian</span><span class="p">(</span><span class="n">x_mu</span><span class="p">,</span> <span class="n">R_mu</span><span class="p">,</span> <span class="n">std</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
  <span class="n">__</span><span class="p">,</span> <span class="n">R_samples_with_theseus</span> <span class="o">=</span> <span class="nf">sample_from_se3_gaussian_with_theseus</span><span class="p">(</span><span class="n">x_mu</span><span class="p">,</span> <span class="n">R_mu</span><span class="p">,</span> <span class="n">std</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
  <span class="n">rots</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">R_samples</span><span class="p">)</span>
  <span class="n">rots_with_theseus</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">R_samples_with_theseus</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">sample_from_se3_gaussian</span><span class="sh">'</span><span class="p">)</span>
<span class="n">fig</span> <span class="o">=</span> <span class="nf">plot_rotations</span><span class="p">(</span><span class="n">rots</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">stds</span><span class="p">)</span>
<span class="n">fig</span><span class="p">.</span><span class="nf">to_html</span><span class="p">(</span><span class="sh">'</span><span class="s">se3_gaussian.html</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">sample_from_se3_gaussian_with_theseus</span><span class="sh">'</span><span class="p">)</span>
<span class="n">fig</span> <span class="o">=</span> <span class="nf">plot_rotations</span><span class="p">(</span><span class="n">rots_with_theseus</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">stds</span><span class="p">)</span>
<span class="n">fig</span><span class="p">.</span><span class="nf">to_html</span><span class="p">(</span><span class="sh">'</span><span class="s">se3_gaussian_th.html</span><span class="sh">'</span><span class="p">)</span>

<span class="c1"># Outputs: 
# An example of SE(3) group element:
# tensor([[[-0.7645,  0.1293, -0.6315, -0.8293],
#          [ 0.6156, -0.1438, -0.7748, -1.6137],
#          [-0.1910, -0.9811,  0.0303, -0.2147],
#          [ 0.0000,  0.0000,  0.0000,  1.0000]]])</span></code></pre></figure> <p>sample_from_se3_gaussian:</p> <iframe src="/assets/img/posts/se3diff/se3_gaussian.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <p>sample_from_se3_gaussian_with_theseus</p> <iframe src="/assets/img/posts/se3diff/se3_gaussian_th.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># A spreadout SE(3) Gaussian, std = 0.4
</span><span class="n">torch</span><span class="p">.</span><span class="nf">manual_seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">x_samples</span><span class="p">,</span> <span class="n">R_samples</span> <span class="o">=</span> <span class="nf">sample_from_se3_gaussian</span><span class="p">(</span><span class="n">x_mu</span><span class="p">,</span> <span class="n">R_mu</span><span class="p">,</span> <span class="mf">0.4</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>

<span class="n">H</span> <span class="o">=</span> <span class="nf">construct_roto_trans</span><span class="p">(</span><span class="n">x_samples</span><span class="p">,</span> <span class="n">R_samples</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">H</span><span class="p">,</span> <span class="n">H_mu</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">colors</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">H</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scene</span> <span class="o">=</span> <span class="nf">visualize_grasps</span><span class="p">(</span><span class="n">Hs</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">.</span><span class="nf">numpy</span><span class="p">(),</span> <span class="n">show</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span>


<span class="c1"># A tight SE(3) Gaussian, std = 0.25
</span><span class="n">torch</span><span class="p">.</span><span class="nf">manual_seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">x_samples</span><span class="p">,</span> <span class="n">R_samples</span> <span class="o">=</span> <span class="nf">sample_from_se3_gaussian</span><span class="p">(</span><span class="n">x_mu</span><span class="p">,</span> <span class="n">R_mu</span><span class="p">,</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>

<span class="n">H</span> <span class="o">=</span> <span class="nf">construct_roto_trans</span><span class="p">(</span><span class="n">x_samples</span><span class="p">,</span> <span class="n">R_samples</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">H</span><span class="p">,</span> <span class="n">H_mu</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">colors</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">H</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scene</span> <span class="o">=</span> <span class="nf">visualize_grasps</span><span class="p">(</span><span class="n">Hs</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">.</span><span class="nf">numpy</span><span class="p">(),</span> <span class="n">show</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Note that each fork is of the same size!</span><span class="sh">'</span><span class="p">)</span></code></pre></figure> <p>\(\sigma = 0.40\)</p> <iframe src="/assets/img/posts/se3diff/se3_gaussian1.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <p>\(\sigma = 0.25\)</p> <iframe src="/assets/img/posts/se3diff/se3_gaussian2.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <p>Note that each fork is of the same size!</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># Evaluate log probability of SE(3) poses in SE(3) Gaussian distribution
</span><span class="k">def</span> <span class="nf">se3_log_probability_normal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">x_tar</span><span class="p">,</span> <span class="n">R_tar</span><span class="p">,</span> <span class="n">std</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
  <span class="sh">'''</span><span class="s">
  x: translation samples
  R: rotation samples

  x_tar: mean translation of SE-3 gaussian
  R_tar: mean rotation of SE-3 gaussian
  std: standard deviation of the SE-3 gaussian
  </span><span class="sh">'''</span>
  <span class="k">assert</span> <span class="n">x</span><span class="p">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">x_tar</span><span class="p">.</span><span class="n">shape</span>
  <span class="k">assert</span> <span class="n">R</span><span class="p">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">R_tar</span><span class="p">.</span><span class="n">shape</span>

  <span class="c1"># Mean rotation as theseus object
</span>  <span class="n">_R_tar</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">()</span>
  <span class="n">_R_tar</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">R_tar</span><span class="p">)</span>

  <span class="c1"># rotation samples as theseus object
</span>  <span class="n">_R</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">()</span>
  <span class="n">_R</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
  <span class="n">R</span> <span class="o">=</span> <span class="n">_R</span>

  <span class="c1"># Compute distance in R^3 + SO(3)
</span>  <span class="c1"># Rotation distance
</span>  <span class="n">R_tar_inv</span> <span class="o">=</span> <span class="n">_R_tar</span><span class="p">.</span><span class="nf">inverse</span><span class="p">()</span>
  <span class="n">dR</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">()</span>
  <span class="n">dR_rot</span> <span class="o">=</span> <span class="n">R_tar_inv</span><span class="p">.</span><span class="nf">to_matrix</span><span class="p">()</span> <span class="o">@</span> <span class="n">R</span><span class="p">.</span><span class="nf">to_matrix</span><span class="p">()</span>
  <span class="n">dR</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">dR_rot</span><span class="p">)</span>
  <span class="n">dv</span> <span class="o">=</span> <span class="n">dR</span><span class="p">.</span><span class="nf">log_map</span><span class="p">()</span> <span class="c1"># the vector representation for the rotation difference
</span>
  <span class="c1"># translation distance
</span>  <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_tar</span><span class="p">)</span>

  <span class="c1"># 6D distance
</span>  <span class="n">dist</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">dx</span><span class="p">,</span> <span class="n">dv</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

  <span class="c1"># compute the log probability up to a constant term, which we don't care
</span>  <span class="k">return</span> <span class="o">-</span><span class="p">.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">dist</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">std</span><span class="p">.</span><span class="nf">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>


<span class="n">std</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="n">log_prob</span> <span class="o">=</span> <span class="nf">se3_log_probability_normal</span><span class="p">(</span><span class="n">x_samples</span><span class="p">,</span> <span class="n">R_samples</span><span class="p">,</span> <span class="n">x_mu</span><span class="p">,</span> <span class="n">R_mu</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span>

<span class="c1"># probability of each sample comping from the SE-3 samples
</span><span class="n">colors</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">B</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">colors</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">log_prob</span> <span class="o">-</span> <span class="n">log_prob</span><span class="p">.</span><span class="nf">min</span><span class="p">())</span><span class="o">/</span><span class="p">(</span><span class="n">log_prob</span><span class="p">.</span><span class="nf">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">log_prob</span><span class="p">.</span><span class="nf">min</span><span class="p">())</span>
<span class="n">colors</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">-</span> <span class="p">(</span><span class="n">log_prob</span> <span class="o">-</span> <span class="n">log_prob</span><span class="p">.</span><span class="nf">min</span><span class="p">())</span><span class="o">/</span><span class="p">(</span><span class="n">log_prob</span><span class="p">.</span><span class="nf">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">log_prob</span><span class="p">.</span><span class="nf">min</span><span class="p">())</span>

<span class="n">scene</span> <span class="o">=</span> <span class="nf">visualize_grasps</span><span class="p">(</span><span class="n">Hs</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">.</span><span class="nf">numpy</span><span class="p">(),</span> <span class="n">show</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">These forks are colored by the log probability, the greener the greater the logp &lt; 0</span><span class="sh">'</span><span class="p">)</span></code></pre></figure> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/se3diff/se3_gaussian_prob-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/se3diff/se3_gaussian_prob-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/se3diff/se3_gaussian_prob-1400.webp"></source> <img src="/assets/img/posts/se3diff/se3_gaussian_prob.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p>These forks are colored by the log probability, the greener the greater the \(logp &lt; 0\)</p> <p>We have calculated the SE(3) log probability density evaluated at \(x(t)\) or trans: \(x(t)\) and rot: \(R(t)\), up to a constant term. We now want to do 2 things:</p> <ol> <li>Compute the score, i.e. take the gradient of log probability wrt \(x(t)\) and \(R(t)\)</li> </ol> <p>This can be done analytically with the IGSO3 formula and the quotient rule as done in FrameDiff (Yim et al ICLR 2023). Or can be done via <code class="language-plaintext highlighter-rouge">theseus</code>’s compatibility with autodiff. We will use the latter in this notebook.</p> <p>The score is of the same dimension of the data, which has 6 degrees of freedom. We will denote as \(v = (x, y, z, w_x, w_y, w_z)\).</p> <ol> <li>Move one step in the direction of the score.</li> </ol> <p>This involves doing integration of small steps on the SO(3) manifold, converting the small axis-angle vector (in so(3)) to rotation matrix (in SO(3)) step by step as illustrated in the following figure.</p> <p><img title="" alt="Alt text" src="https://d3i71xaburhd42.cloudfront.net/3a75252bab18250b8de8be28ec376db6cfc04084/10-Figure10-1.png"></p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># Move an SE(3) pose given the score of a Gaussian Distribution in SE(3)
</span>
<span class="c1"># compute the SE(3) scores
</span><span class="k">def</span> <span class="nf">se3_score_normal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">x_tar</span><span class="p">,</span> <span class="n">R_tar</span><span class="p">,</span> <span class="n">std</span><span class="p">):</span>
  <span class="sh">'''</span><span class="s">
  x: translational samples. (..., 3)
  R: rotational samples. (..., 3, 3)

  v: se3 scores. (..., 6)
  </span><span class="sh">'''</span>

  <span class="c1"># theseus object
</span>  <span class="n">_R</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">()</span>
  <span class="n">_R</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
  <span class="n">R</span> <span class="o">=</span> <span class="n">_R</span>

  <span class="c1"># construct trainable 6D vector
</span>  <span class="n">v</span> <span class="o">=</span> <span class="n">R</span><span class="p">.</span><span class="nf">log_map</span><span class="p">()</span>
  <span class="n">x_theta</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">x_theta</span><span class="p">.</span><span class="nf">requires_grad_</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

  <span class="c1"># assign components from 6D vector
</span>  <span class="c1"># looks redundant but this preserves the gradient hook and computation graph
</span>  <span class="n">x</span> <span class="o">=</span> <span class="n">x_theta</span><span class="p">[...,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">R</span> <span class="o">=</span> <span class="n">SO3</span><span class="p">.</span><span class="nf">exp_map</span><span class="p">(</span><span class="n">x_theta</span><span class="p">[...,</span> <span class="mi">3</span><span class="p">:])</span>

  <span class="c1"># compute log probability with gradient hooked tensors
</span>  <span class="n">d</span> <span class="o">=</span> <span class="nf">se3_log_probability_normal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">x_tar</span><span class="p">,</span> <span class="n">R_tar</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span>
  <span class="n">v</span> <span class="o">=</span> <span class="nf">grad</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="nf">sum</span><span class="p">(),</span> <span class="n">x_theta</span><span class="p">,</span> <span class="n">only_inputs</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">v</span>

<span class="c1"># (x, R) + v
</span><span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="c1"># compose rotations
</span>    <span class="n">rot</span> <span class="o">=</span> <span class="n">SO3</span><span class="p">.</span><span class="nf">exp_map</span><span class="p">(</span><span class="n">v</span><span class="p">[...,</span> <span class="mi">3</span><span class="p">:]).</span><span class="nf">to_matrix</span><span class="p">()</span>
    <span class="n">R_1</span> <span class="o">=</span> <span class="n">R</span> <span class="o">@</span> <span class="n">rot</span>

    <span class="c1"># compose translations
</span>    <span class="n">x_1</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">v</span><span class="p">[...,:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">x_1</span><span class="p">,</span> <span class="n">R_1</span>


<span class="c1"># a helper function for scaling the roto-translation vector
# using the proper scaling of rotations
</span><span class="k">def</span> <span class="nf">scale_roto_trans_vec</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
  <span class="k">assert</span> <span class="n">v</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">scale</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="n">trans</span><span class="p">,</span> <span class="n">roto</span> <span class="o">=</span> <span class="n">v</span><span class="p">[...,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">v</span><span class="p">[...,</span> <span class="mi">3</span><span class="p">:]</span>

  <span class="c1"># roto vector scaling
</span>  <span class="n">R</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">exp_map</span><span class="p">(</span><span class="n">roto</span><span class="p">).</span><span class="nf">to_matrix</span><span class="p">()</span>
  <span class="n">R</span> <span class="o">=</span> <span class="nf">scale_rotations</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
  <span class="n">roto</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">(</span><span class="n">tensor</span><span class="o">=</span><span class="n">R</span><span class="p">).</span><span class="nf">log_map</span><span class="p">()</span>

  <span class="c1"># trans vector scaling
</span>  <span class="n">trans</span> <span class="o">=</span> <span class="n">trans</span> <span class="o">*</span> <span class="n">scale</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">]</span>

  <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">trans</span><span class="p">,</span> <span class="n">roto</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>


<span class="c1"># follow se3 scores, keeping intermediate states and outputs the scene
</span><span class="k">def</span> <span class="nf">follow_score_se3</span><span class="p">(</span><span class="n">x_truth</span><span class="p">,</span> <span class="n">R_truth</span><span class="p">,</span> <span class="n">std_min</span><span class="p">,</span> <span class="n">std_max</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">naive_scale</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">41</span><span class="p">):</span>

  <span class="k">assert</span> <span class="n">x_truth</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">R_truth</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
  <span class="n">H_truth</span> <span class="o">=</span> <span class="nf">construct_roto_trans</span><span class="p">(</span><span class="n">x_truth</span><span class="p">,</span> <span class="n">R_truth</span><span class="p">)</span>

  <span class="c1"># start with some random position and rotation in SE(3)
</span>  <span class="n">torch</span><span class="p">.</span><span class="nf">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
  <span class="n">R</span> <span class="o">=</span> <span class="n">SO3</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">to_matrix</span><span class="p">()</span> <span class="c1"># the prior is USO3
</span>  <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># the prior is Normal
</span>
  <span class="c1"># std schedules
</span>  <span class="n">stds</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="n">std_max</span><span class="p">,</span> <span class="n">std_min</span><span class="p">,</span> <span class="n">T</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">sqrt2_dt</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>

  <span class="c1"># init SE3 components
</span>  <span class="n">H_trj</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

  <span class="c1"># following the scores
</span>  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">tqdm</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">T</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
    <span class="n">H0</span> <span class="o">=</span> <span class="nf">construct_roto_trans</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nf">detach</span><span class="p">(),</span> <span class="n">R</span><span class="p">.</span><span class="nf">detach</span><span class="p">())</span>
    <span class="n">H_trj</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">H_trj</span><span class="p">,</span> <span class="n">H0</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">v</span> <span class="o">=</span> <span class="nf">se3_score_normal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">x_truth</span><span class="p">,</span> <span class="n">R_truth</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="n">stds</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span>

    <span class="n">_s</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">dt</span> <span class="k">if</span> <span class="n">naive_scale</span> <span class="k">else</span> <span class="nf">scale_roto_trans_vec</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="n">dt</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">noise_on</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">:</span>
      <span class="n">z</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn_like</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
      <span class="n">_s</span> <span class="o">+=</span> <span class="n">sqrt2_dt</span> <span class="o">*</span> <span class="n">z</span> <span class="k">if</span> <span class="n">naive_scale</span> <span class="k">else</span> <span class="nf">scale_roto_trans_vec</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="n">sqrt2_dt</span><span class="p">]))</span>

    <span class="c1"># one step following the score
</span>    <span class="n">x</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="nf">step</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">_s</span><span class="p">)</span>

  <span class="c1"># for vis
</span>  <span class="n">H</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">H_trj</span><span class="p">,</span> <span class="n">H_truth</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">colors</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros_like</span><span class="p">(</span><span class="n">H</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
  <span class="n">colors</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">H_trj</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">colors</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">H_trj</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

  <span class="n">scene</span> <span class="o">=</span> <span class="nf">visualize_grasps</span><span class="p">(</span><span class="n">Hs</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">.</span><span class="nf">numpy</span><span class="p">(),</span> <span class="n">show</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">H</span><span class="p">,</span> <span class="n">scene</span></code></pre></figure> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Un-annealed ODE-like with large std...</span><span class="sh">'</span><span class="p">)</span>
<span class="n">__</span><span class="p">,</span> <span class="n">scene</span> <span class="o">=</span> <span class="nf">follow_score_se3</span><span class="p">(</span><span class="n">x_mu</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span> <span class="p">...],</span> <span class="n">R_mu</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span> <span class="p">...],</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Un-annealed ODE-like with small std...</span><span class="sh">'</span><span class="p">)</span>
<span class="n">__</span><span class="p">,</span> <span class="n">scene</span> <span class="o">=</span> <span class="nf">follow_score_se3</span><span class="p">(</span><span class="n">x_mu</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span> <span class="p">...],</span> <span class="n">R_mu</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span> <span class="p">...],</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Annealed ODE-like</span><span class="sh">'</span><span class="p">)</span>
<span class="n">__</span><span class="p">,</span> <span class="n">scene</span> <span class="o">=</span> <span class="nf">follow_score_se3</span><span class="p">(</span><span class="n">x_mu</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span> <span class="p">...],</span> <span class="n">R_mu</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span> <span class="p">...],</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span>


<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Un-annealed Langevin dyanmics with large std...</span><span class="sh">'</span><span class="p">)</span>
<span class="n">__</span><span class="p">,</span> <span class="n">scene</span> <span class="o">=</span> <span class="nf">follow_score_se3</span><span class="p">(</span><span class="n">x_mu</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span> <span class="p">...],</span> <span class="n">R_mu</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span> <span class="p">...],</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Un-annealed Langevin dyanmics with small std...</span><span class="sh">'</span><span class="p">)</span>
<span class="n">__</span><span class="p">,</span> <span class="n">scene</span> <span class="o">=</span> <span class="nf">follow_score_se3</span><span class="p">(</span><span class="n">x_mu</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span> <span class="p">...],</span> <span class="n">R_mu</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span> <span class="p">...],</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Annealed Langevin dyanmics</span><span class="sh">'</span><span class="p">)</span>
<span class="n">__</span><span class="p">,</span> <span class="n">scene</span> <span class="o">=</span> <span class="nf">follow_score_se3</span><span class="p">(</span><span class="n">x_mu</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span> <span class="p">...],</span> <span class="n">R_mu</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span> <span class="p">...],</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span></code></pre></figure> <iframe src="/assets/img/posts/se3diff/follow1.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <iframe src="/assets/img/posts/se3diff/follow2.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <iframe src="/assets/img/posts/se3diff/follow3.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <iframe src="/assets/img/posts/se3diff/follow4.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <iframe src="/assets/img/posts/se3diff/follow5.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <iframe src="/assets/img/posts/se3diff/follow6.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <h3 id="4-training-se3-diffusion-model">4. Training SE(3) Diffusion model</h3> <h4 id="toy-example-1">Toy example 1</h4> <p>Here we want to train a model that generates a 2 SE(3) elements.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># Training a Toy SE(3) Diffusion Model
</span>
<span class="c1"># getting the data
</span><span class="k">def</span> <span class="nf">get_sample_from_data</span><span class="p">(</span><span class="n">B</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
  <span class="n">x_data</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">([[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span>
                          <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7</span><span class="p">]])</span>
  <span class="n">theta_data</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                              <span class="p">[</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4</span><span class="p">]])</span>
  <span class="n">R_data</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">exp_map</span><span class="p">(</span><span class="n">theta_data</span><span class="p">).</span><span class="nf">to_matrix</span><span class="p">()</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="p">))</span>
  <span class="n">_x</span> <span class="o">=</span> <span class="n">x_data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">...]</span>
  <span class="n">_R</span> <span class="o">=</span> <span class="n">R_data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">...]</span>
  <span class="k">return</span> <span class="n">_x</span><span class="p">,</span> <span class="n">_R</span>


<span class="c1"># defines the scheduling of std schedule with SDE with no drift
# this is the variance schedule we chose
</span><span class="k">def</span> <span class="nf">marginal_prob_std</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">((</span><span class="n">sigma</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">sigma</span><span class="p">)))</span>


<span class="c1"># Define the layer and model
</span>
<span class="c1"># Time step embedding
</span><span class="k">class</span> <span class="nc">GaussianFourierProjection</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
  <span class="sh">'''</span><span class="s">Gaussian random features for encoding time steps.
  </span><span class="sh">'''</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">embed_dim</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">30.</span><span class="p">):</span>
    <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
    <span class="n">self</span><span class="p">.</span><span class="n">W</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="n">embed_dim</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># fixed random projection
</span>
  <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">x_proj</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">einsum</span><span class="p">(</span><span class="sh">'</span><span class="s">...,b-&gt;...b</span><span class="sh">'</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">W</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="n">pi</span>
    <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">torch</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">x_proj</span><span class="p">),</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">x_proj</span><span class="p">)],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>


<span class="c1"># Naive all linears
</span><span class="k">class</span> <span class="nc">NaiveSE3DiffusionModel</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
  <span class="sh">'''</span><span class="s">Basic NN with linears
  input the noised x (B, 3) and R (B, 3, 3) at time t (B, )
  output the predicted scores v (B, 6)
  </span><span class="sh">'''</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>

    <span class="n">input_size</span> <span class="o">=</span> <span class="mi">12</span> <span class="c1"># we take a translation and flattened rotation
</span>                    <span class="c1"># one can do a 6-dim where we take the Log of the rotation
</span>    <span class="n">enc_dim</span> <span class="o">=</span> <span class="mi">128</span>
    <span class="n">output_size</span> <span class="o">=</span> <span class="mi">6</span>

    <span class="n">self</span><span class="p">.</span><span class="n">network</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span>
        <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">enc_dim</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span>
        <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(),</span>
        <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span>
        <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(),</span>
        <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">output_size</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Time Embedings Encoder
</span>    <span class="n">self</span><span class="p">.</span><span class="n">time_embed</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span>
        <span class="nc">GaussianFourierProjection</span><span class="p">(</span><span class="n">embed_dim</span><span class="o">=</span><span class="n">enc_dim</span><span class="p">),</span>
        <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">enc_dim</span><span class="p">,</span> <span class="n">enc_dim</span><span class="p">),</span>
        <span class="n">nn</span><span class="p">.</span><span class="nc">SiLU</span><span class="p">(),</span>
    <span class="p">)</span>
    <span class="n">self</span><span class="p">.</span><span class="n">x_embed</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span>
        <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">input_size</span><span class="p">,</span> <span class="n">enc_dim</span><span class="p">),</span>
        <span class="n">nn</span><span class="p">.</span><span class="nc">SiLU</span><span class="p">(),</span>
    <span class="p">)</span>


  <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">std</span> <span class="o">=</span> <span class="nf">marginal_prob_std</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">x_R_input</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">x_embed</span><span class="p">(</span><span class="n">x_R_input</span><span class="p">)</span>
    <span class="n">z_time</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">time_embed</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">z_in</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">z</span><span class="p">,</span> <span class="n">z_time</span><span class="p">),</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">network</span><span class="p">(</span><span class="n">z_in</span><span class="p">)</span>

    <span class="c1"># the 1/v scaling is necessary for numerical stability
</span>    <span class="c1"># as we don't want the NN to predict scores say, from 0.001 to 100.0
</span>    <span class="k">return</span> <span class="n">v</span> <span class="o">/</span> <span class="p">(</span><span class="n">std</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">].</span><span class="nf">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>


<span class="c1"># Training
</span><span class="n">model</span> <span class="o">=</span> <span class="nc">NaiveSE3DiffusionModel</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">optim</span><span class="p">.</span><span class="nc">AdamW</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.0005</span><span class="p">)</span>

<span class="n">K</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">B</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">EPS</span> <span class="o">=</span> <span class="mf">1e-3</span>
<span class="n">loss_trj</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">tqdm</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">K</span><span class="p">)):</span>

    <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">EPS</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">+</span> <span class="n">EPS</span> <span class="c1"># t ~ 0 will cause numerical instability
</span>    <span class="n">std</span> <span class="o">=</span> <span class="nf">marginal_prob_std</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1"># compute scheuling of std at t=t, increasing with t
</span>    <span class="n">x</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="nf">get_sample_from_data</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="c1"># batch samples
</span>    <span class="n">x_eps</span><span class="p">,</span> <span class="n">R_eps</span> <span class="o">=</span> <span class="nf">sample_from_se3_gaussian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span> <span class="c1"># noised samples
</span>
    <span class="n">v_tar</span> <span class="o">=</span> <span class="nf">se3_score_normal</span><span class="p">(</span><span class="n">x_eps</span><span class="p">,</span> <span class="n">R_eps</span><span class="p">,</span> <span class="n">x_tar</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">R_tar</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="n">std</span><span class="p">)</span> <span class="c1"># estimate scores of noised samples
</span>    <span class="n">v_pred</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">x_eps</span><span class="p">,</span> <span class="n">R_eps</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="c1"># predicted scores from model
</span>    <span class="n">loss</span> <span class="o">=</span> <span class="n">std</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(((</span><span class="n">v_pred</span> <span class="o">-</span> <span class="n">v_tar</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">).</span><span class="nf">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># score matching loss
</span>    <span class="n">loss_trj</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">loss_trj</span><span class="p">,</span> <span class="n">loss</span><span class="p">.</span><span class="nf">mean</span><span class="p">().</span><span class="nf">detach</span><span class="p">()[</span><span class="bp">None</span><span class="p">]),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Backward pass and optimization
</span>    <span class="n">optimizer</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>
    <span class="n">loss</span><span class="p">.</span><span class="nf">mean</span><span class="p">().</span><span class="nf">backward</span><span class="p">()</span>
    <span class="n">optimizer</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">loss_trj</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span></code></pre></figure> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/se3diff/training1-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/se3diff/training1-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/se3diff/training1-1400.webp"></source> <img src="/assets/img/posts/se3diff/training1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># Given the model run reverse sampling using the step function we defined
</span><span class="k">def</span> <span class="nf">sample_se3</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">data_gen</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">naive_scale</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">37</span><span class="p">):</span>

  <span class="c1"># random starting point
</span>  <span class="n">torch</span><span class="p">.</span><span class="nf">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
  <span class="n">R0</span> <span class="o">=</span> <span class="n">SO3</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">B</span><span class="p">).</span><span class="nf">to_matrix</span><span class="p">()</span>
  <span class="n">x0</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="n">T</span> <span class="o">+</span> <span class="n">eps</span>

    <span class="n">v</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">k</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
    <span class="n">_s</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">dt</span> <span class="k">if</span> <span class="n">naive_scale</span> <span class="k">else</span> <span class="nf">scale_roto_trans_vec</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="p">))</span>

    <span class="k">if</span> <span class="n">noise_on</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">T</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">z</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn_like</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
      <span class="n">_s</span> <span class="o">+=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">z</span> <span class="k">if</span> <span class="n">naive_scale</span> <span class="k">else</span> <span class="nf">scale_roto_trans_vec</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="p">))</span>

    <span class="n">x0</span><span class="p">,</span> <span class="n">R0</span> <span class="o">=</span> <span class="nf">step</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">R0</span><span class="p">,</span> <span class="n">_s</span><span class="p">)</span>

  <span class="c1"># generated samples (red)
</span>  <span class="n">H_gen</span> <span class="o">=</span> <span class="nf">construct_roto_trans</span><span class="p">(</span><span class="n">x0</span><span class="p">.</span><span class="nf">detach</span><span class="p">(),</span> <span class="n">R0</span><span class="p">.</span><span class="nf">detach</span><span class="p">())</span>
  <span class="n">colors_gen</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">B</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
  <span class="n">colors_gen</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

  <span class="c1"># real samples (green)
</span>  <span class="n">xd</span><span class="p">,</span> <span class="n">Rd</span> <span class="o">=</span> <span class="nf">data_gen</span><span class="p">(</span><span class="n">B</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
  <span class="n">H_dat</span> <span class="o">=</span> <span class="nf">construct_roto_trans</span><span class="p">(</span><span class="n">xd</span><span class="p">,</span> <span class="n">Rd</span><span class="p">)</span>
  <span class="n">colors_dat</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
  <span class="n">colors_dat</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

  <span class="n">H</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">H_gen</span><span class="p">,</span> <span class="n">H_dat</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">colors_gen</span><span class="p">,</span> <span class="n">colors_dat</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

  <span class="n">scene</span> <span class="o">=</span> <span class="nf">visualize_grasps</span><span class="p">(</span><span class="n">Hs</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">c</span><span class="p">.</span><span class="nf">numpy</span><span class="p">(),</span> <span class="n">show</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">H_gen</span><span class="p">,</span> <span class="n">scene</span></code></pre></figure> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Sampling from trained model by following score prediction</span><span class="sh">'</span><span class="p">)</span>
<span class="n">__</span><span class="p">,</span> <span class="n">scene</span> <span class="o">=</span> <span class="nf">sample_se3</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">get_sample_from_data</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Sampling from trained model by Langevin dynamics</span><span class="sh">'</span><span class="p">)</span>
<span class="n">H</span><span class="p">,</span> <span class="n">scene</span> <span class="o">=</span> <span class="nf">sample_se3</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">get_sample_from_data</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span>
<span class="nf">plot_rotations</span><span class="p">([</span><span class="n">R_dummy</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">H</span><span class="p">[...,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="nf">get_sample_from_data</span><span class="p">(</span><span class="mi">10</span><span class="p">)[</span><span class="mi">1</span><span class="p">]])</span></code></pre></figure> <iframe src="/assets/img/posts/se3diff/ex1sample1.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <iframe src="/assets/img/posts/se3diff/ex1sample2.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <iframe src="/assets/img/posts/se3diff/ex1so3.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <h4 id="2-toy-example-2">2. Toy example 2</h4> <p>Here we want to train a model that generates a 4 SE(3) elements.</p> <p>We’ll later see that the translation part defines unbalanced sampling and tricks to overcome it.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># try different distributions
</span><span class="k">def</span> <span class="nf">get_sample_from_data_2</span><span class="p">(</span><span class="n">B</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">x_data</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">([[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span>
                           <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.7</span><span class="p">],</span>
                           <span class="p">[</span><span class="mf">3.1</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.4</span><span class="p">],</span> <span class="c1"># this one is significantly more further away
</span>                           <span class="p">[</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">]])</span>
    <span class="n">theta_data</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nc">Tensor</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                               <span class="p">[</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4</span><span class="p">],</span>
                               <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.4</span><span class="p">],</span>
                               <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]])</span>

    <span class="n">R_data</span> <span class="o">=</span> <span class="nc">SO3</span><span class="p">().</span><span class="nf">exp_map</span><span class="p">(</span><span class="n">theta_data</span><span class="p">).</span><span class="nf">to_matrix</span><span class="p">()</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="n">B</span><span class="p">,))</span>
    <span class="n">_x</span> <span class="o">=</span> <span class="n">x_data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">_R</span> <span class="o">=</span> <span class="n">R_data</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">...]</span>
    <span class="k">return</span> <span class="n">_x</span><span class="p">,</span> <span class="n">_R</span>


<span class="c1"># the same training, just copied and pasted here
</span><span class="n">model</span> <span class="o">=</span> <span class="nc">NaiveSE3DiffusionModel</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">optim</span><span class="p">.</span><span class="nc">AdamW</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.0005</span><span class="p">)</span>


<span class="n">K</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">B</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">loss_trj</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">tqdm</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">K</span><span class="p">)):</span>

    <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">EPS</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">+</span> <span class="n">EPS</span>
    <span class="n">std</span> <span class="o">=</span> <span class="nf">marginal_prob_std</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="nf">get_sample_from_data_2</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="n">x_eps</span><span class="p">,</span> <span class="n">R_eps</span> <span class="o">=</span> <span class="nf">sample_from_se3_gaussian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span>

    <span class="n">v_tar</span> <span class="o">=</span> <span class="nf">se3_score_normal</span><span class="p">(</span><span class="n">x_eps</span><span class="p">,</span> <span class="n">R_eps</span><span class="p">,</span> <span class="n">x_tar</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">R_tar</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="n">std</span><span class="p">)</span>
    <span class="n">v_pred</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">x_eps</span><span class="p">,</span> <span class="n">R_eps</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">std</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span><span class="p">(((</span><span class="n">v_pred</span> <span class="o">-</span> <span class="n">v_tar</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">).</span><span class="nf">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">loss_trj</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">loss_trj</span><span class="p">,</span> <span class="n">loss</span><span class="p">.</span><span class="nf">mean</span><span class="p">().</span><span class="nf">detach</span><span class="p">()[</span><span class="bp">None</span><span class="p">]),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">optimizer</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>
    <span class="n">loss</span><span class="p">.</span><span class="nf">mean</span><span class="p">().</span><span class="nf">backward</span><span class="p">()</span>
    <span class="n">optimizer</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">loss_trj</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span></code></pre></figure> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/se3diff/training2-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/se3diff/training2-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/se3diff/training2-1400.webp"></source> <img src="/assets/img/posts/se3diff/training2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Sampling from trained model by following score prediction</span><span class="sh">'</span><span class="p">)</span>
<span class="n">__</span><span class="p">,</span> <span class="n">scene</span> <span class="o">=</span> <span class="nf">sample_se3</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">get_sample_from_data_2</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span>


<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Sampling from trained model by Langevin dynamics</span><span class="sh">'</span><span class="p">)</span>
<span class="n">H</span><span class="p">,</span> <span class="n">scene</span> <span class="o">=</span> <span class="nf">sample_se3</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">get_sample_from_data_2</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span>

<span class="nf">plot_rotations</span><span class="p">([</span><span class="n">R_dummy</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">H</span><span class="p">[...,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="nf">get_sample_from_data_2</span><span class="p">(</span><span class="mi">20</span><span class="p">)[</span><span class="mi">1</span><span class="p">]])</span>

<span class="nf">print</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Notice there is a relative sampling bias with respective to the more distant point</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">This is because for translational sampling, the more distance from the original, the less likely it will be achieved</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">One can simply make the system of zero COM.</span><span class="sh">'</span><span class="p">)</span></code></pre></figure> <iframe src="/assets/img/posts/se3diff/ex2sample1.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <iframe src="/assets/img/posts/se3diff/ex2sample2.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <iframe src="/assets/img/posts/se3diff/ex2so3.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <p>Notice there is a relative sampling bias with respective to the more distant point This is because for translational sampling, the more distance from the original, the less likely it will be achieved One can simply make the system of zero COM.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># Let's redo th training by centering the SE(3) distribution at origin
</span>
<span class="n">offset</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="mf">0.6500</span><span class="p">,</span> <span class="mf">1.0000</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.6000</span><span class="p">])</span>

<span class="n">model</span> <span class="o">=</span> <span class="nc">NaiveSE3DiffusionModel</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">optim</span><span class="p">.</span><span class="nc">AdamW</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.0005</span><span class="p">)</span>

<span class="c1"># again copied and pasted
# should've put this into a function but well..
</span><span class="n">K</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">B</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">loss_trj</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">tqdm</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">K</span><span class="p">)):</span>

    <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">EPS</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">+</span> <span class="n">EPS</span>
    <span class="n">std</span> <span class="o">=</span> <span class="nf">marginal_prob_std</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="nf">get_sample_from_data_2</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

    <span class="c1"># the only difference is the centering
</span>    <span class="n">x</span> <span class="o">-=</span> <span class="n">offset</span>

    <span class="n">x_eps</span><span class="p">,</span> <span class="n">R_eps</span> <span class="o">=</span> <span class="nf">sample_from_se3_gaussian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span>
    <span class="n">v_tar</span> <span class="o">=</span> <span class="nf">se3_score_normal</span><span class="p">(</span><span class="n">x_eps</span><span class="p">,</span> <span class="n">R_eps</span><span class="p">,</span> <span class="n">x_tar</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">R_tar</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="n">std</span><span class="p">)</span>
    <span class="n">v_pred</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">x_eps</span><span class="p">,</span> <span class="n">R_eps</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">std</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span><span class="p">(((</span><span class="n">v_pred</span> <span class="o">-</span> <span class="n">v_tar</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">).</span><span class="nf">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">loss_trj</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">loss_trj</span><span class="p">,</span> <span class="n">loss</span><span class="p">.</span><span class="nf">mean</span><span class="p">().</span><span class="nf">detach</span><span class="p">()[</span><span class="bp">None</span><span class="p">]),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Backward pass and optimization
</span>    <span class="n">optimizer</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>
    <span class="n">loss</span><span class="p">.</span><span class="nf">mean</span><span class="p">().</span><span class="nf">backward</span><span class="p">()</span>
    <span class="n">optimizer</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">loss_trj</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span></code></pre></figure> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/se3diff/training3-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/se3diff/training3-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/se3diff/training3-1400.webp"></source> <img src="/assets/img/posts/se3diff/training3.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Sampling from trained model by Langevin dynamics</span><span class="sh">'</span><span class="p">)</span>
<span class="n">H</span><span class="p">,</span> <span class="n">scene</span> <span class="o">=</span> <span class="nf">sample_se3</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">get_sample_from_data_2</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span>
<span class="nf">plot_rotations</span><span class="p">([</span><span class="n">R_dummy</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">H</span><span class="p">[...,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="nf">get_sample_from_data_2</span><span class="p">(</span><span class="mi">20</span><span class="p">)[</span><span class="mi">1</span><span class="p">]])</span>
<span class="nf">print</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">The green forks are from un-centered distribution</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Notice that the sampling becomes more balanced by just centering the distribution</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">There are ways to improve the sampling, like scaling.</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Because the roto-translation are coupled, now we have a more balanced samples for the orientation as well.</span><span class="sh">'</span><span class="p">)</span>

<span class="nf">print</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">There are many ways to overcome this, like scaling, sample and recentering, decoupling</span><span class="sh">'</span><span class="p">)</span></code></pre></figure> <iframe src="/assets/img/posts/se3diff/ex2sample3.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <iframe src="/assets/img/posts/se3diff/ex2so3_2.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <p>The green forks are from un-centered distribution Notice that the sampling becomes more balanced by just centering the distribution There are ways to improve the sampling, like scaling. Because the roto-translation are coupled, now we have a more balanced samples for the orientation as well.</p> <p>There are many ways to overcome this, like scaling, sample and recentering, decoupling</p> <h4 id="3-real-example-a-protein">3. Real example: A protein!</h4> <p>Here, we will use a protein’s backbone frames as ONE single SE(3) distribution and see if our NN and framework can learn it.</p> <p>We’ll probably define a more complex / deeper model for this task as we know that the underlying distribution is very complicated.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># Let's use a more complicated SE(3) distribution - protein
</span>
<span class="kn">import</span> <span class="n">pickle</span>

<span class="n">retrain</span> <span class="o">=</span> <span class="bp">False</span> <span class="c1"># turn this on if you want to train it yourself
</span>
<span class="c1"># rotation from 3 points using Gram–Schmidt to construct local basis
# a protein local frame can be constructed using C-alpha, N and C
</span><span class="k">def</span> <span class="nf">from_3_points</span><span class="p">(</span>
        <span class="n">p_neg_x_axis</span><span class="p">:</span> <span class="n">torch</span><span class="p">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">origin</span><span class="p">:</span> <span class="n">torch</span><span class="p">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">p_xy_plane</span><span class="p">:</span> <span class="n">torch</span><span class="p">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span>
    <span class="p">):</span>
        <span class="sh">"""</span><span class="s">
            Implements algorithm 21. Constructs transformations from sets of 3
            points using the Gram-Schmidt algorithm.

            Args:
                p_neg_x_axis: [*, 3] coordinates
                origin: [*, 3] coordinates used as frame origins
                p_xy_plane: [*, 3] coordinates
                eps: Small epsilon value
            Returns:
                A transformation object of shape [*]
        </span><span class="sh">"""</span>
        <span class="n">p_neg_x_axis</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">unbind</span><span class="p">(</span><span class="n">p_neg_x_axis</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">unbind</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">p_xy_plane</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">unbind</span><span class="p">(</span><span class="n">p_xy_plane</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">e0</span> <span class="o">=</span> <span class="p">[</span><span class="n">c1</span> <span class="o">-</span> <span class="n">c2</span> <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">p_neg_x_axis</span><span class="p">)]</span>
        <span class="n">e1</span> <span class="o">=</span> <span class="p">[</span><span class="n">c1</span> <span class="o">-</span> <span class="n">c2</span> <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">p_xy_plane</span><span class="p">,</span> <span class="n">origin</span><span class="p">)]</span>

        <span class="n">denom</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="nf">sum</span><span class="p">((</span><span class="n">c</span> <span class="o">*</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">e0</span><span class="p">))</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
        <span class="n">e0</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="o">/</span> <span class="n">denom</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">e0</span><span class="p">]</span>
        <span class="n">dot</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">((</span><span class="n">c1</span> <span class="o">*</span> <span class="n">c2</span> <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">e0</span><span class="p">,</span> <span class="n">e1</span><span class="p">)))</span>
        <span class="n">e1</span> <span class="o">=</span> <span class="p">[</span><span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span> <span class="o">*</span> <span class="n">dot</span> <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">e0</span><span class="p">,</span> <span class="n">e1</span><span class="p">)]</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="nf">sum</span><span class="p">((</span><span class="n">c</span> <span class="o">*</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">e1</span><span class="p">))</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
        <span class="n">e1</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="o">/</span> <span class="n">denom</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">e1</span><span class="p">]</span>
        <span class="n">e2</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">e0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">e0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">e0</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">e0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">e0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">e0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">]</span>

        <span class="n">rots</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">stack</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">e0</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tup</span><span class="p">],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">rots</span> <span class="o">=</span> <span class="n">rots</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">rots</span><span class="p">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">rots</span>

<span class="c1"># an in-house preprocessed antibody structure
# this should be provided with the notebook
</span><span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="nf">open</span><span class="p">(</span><span class="sh">'</span><span class="s">./AFQ82415.pkl</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">rb</span><span class="sh">'</span><span class="p">))</span>
<span class="n">coordinates</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">from_numpy</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="sh">'</span><span class="s">atom_positions</span><span class="sh">'</span><span class="p">][:</span><span class="mi">101</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">])</span> <span class="c1"># N, Ca, C
</span>
<span class="n">rots</span> <span class="o">=</span> <span class="nf">from_3_points</span><span class="p">(</span><span class="n">coordinates</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coordinates</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">coordinates</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">trans</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[...,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="mf">10.</span> <span class="c1"># we need to scale this in order to get a more balanced samples
</span><span class="n">p</span> <span class="o">=</span> <span class="nf">construct_roto_trans</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">rots</span><span class="p">)</span></code></pre></figure> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># interpolate between residues to augment the data
</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">trans</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">...],</span> <span class="n">trans</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">...]</span>
<span class="n">r1</span><span class="p">,</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">rots</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">...],</span> <span class="n">rots</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">...]</span>

<span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">20</span><span class="p">):</span>
  <span class="n">t</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">t1</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">t2</span>
  <span class="n">r</span> <span class="o">=</span> <span class="nf">slerp</span><span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>
  <span class="n">p</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="nf">construct_roto_trans</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">)))</span>

<span class="n">scene</span> <span class="o">=</span> <span class="nf">visualize_grasps</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span></code></pre></figure> <iframe src="/assets/img/posts/se3diff/prot.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># get samples from backbone
</span><span class="n">prot</span> <span class="o">=</span> <span class="nf">construct_roto_trans</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">rots</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">prot</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_sample_from_protein</span><span class="p">(</span><span class="n">prot</span><span class="o">=</span><span class="n">prot</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>

  <span class="n">n</span> <span class="o">=</span> <span class="n">prot</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="p">))</span>
  <span class="n">H</span> <span class="o">=</span> <span class="n">prot</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">...]</span>
  <span class="n">_x</span> <span class="o">=</span> <span class="n">H</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">_R</span> <span class="o">=</span> <span class="n">H</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">_x</span><span class="p">,</span> <span class="n">_R</span>


<span class="c1"># a deeper model
# We just naively stacked more Linears in between
</span><span class="k">class</span> <span class="nc">NaiveSE3DiffusionModel2</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>

        <span class="n">input_size</span> <span class="o">=</span> <span class="mi">12</span>
        <span class="n">enc_dim</span> <span class="o">=</span> <span class="mi">128</span>
        <span class="n">output_size</span> <span class="o">=</span> <span class="mi">6</span>

        <span class="n">self</span><span class="p">.</span><span class="n">network1</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">enc_dim</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">enc_dim</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">self</span><span class="p">.</span><span class="n">network2</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">enc_dim</span><span class="p">,</span> <span class="mi">128</span><span class="p">),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">ReLU</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">output_size</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1">## Time Embedings Encoder ##
</span>        <span class="n">self</span><span class="p">.</span><span class="n">time_embed</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span>
            <span class="nc">GaussianFourierProjection</span><span class="p">(</span><span class="n">embed_dim</span><span class="o">=</span><span class="n">enc_dim</span><span class="p">),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">enc_dim</span><span class="p">,</span> <span class="n">enc_dim</span><span class="p">),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">SiLU</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">x_embed</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">input_size</span><span class="p">,</span> <span class="n">enc_dim</span><span class="p">),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">SiLU</span><span class="p">(),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">marginal_prob_std</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">((</span><span class="n">sigma</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">sigma</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">marginal_prob_std</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">x_R_input</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">x_embed</span><span class="p">(</span><span class="n">x_R_input</span><span class="p">)</span>
        <span class="n">z_time</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">time_embed</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">z_in</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">z</span><span class="p">,</span> <span class="n">z_time</span><span class="p">),</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">network1</span><span class="p">(</span><span class="n">z_in</span><span class="p">)</span>
        <span class="n">z_in</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">z</span><span class="p">,</span> <span class="n">z_time</span><span class="p">),</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">network2</span><span class="p">(</span><span class="n">z_in</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span><span class="o">/</span><span class="p">(</span><span class="n">std</span><span class="p">[:,</span><span class="bp">None</span><span class="p">].</span><span class="nf">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span></code></pre></figure> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">if</span> <span class="n">retrain</span><span class="p">:</span>
    <span class="n">torch</span><span class="p">.</span><span class="nf">manual_seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

    <span class="n">model</span> <span class="o">=</span> <span class="nc">NaiveSE3DiffusionModel2</span><span class="p">()</span>
    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">optim</span><span class="p">.</span><span class="nc">AdamW</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">(),</span> <span class="n">lr</span><span class="o">=</span><span class="mf">0.0005</span><span class="p">)</span>

    <span class="n">K</span> <span class="o">=</span> <span class="mi">30000</span>
    <span class="n">B</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">loss_trj</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">tqdm</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">K</span><span class="p">)):</span>

        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">EPS</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">+</span> <span class="n">EPS</span> <span class="c1"># t ~ 0 will cause numerical instability
</span>        <span class="n">std</span> <span class="o">=</span> <span class="nf">marginal_prob_std</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="c1"># compute scheuling of std at t=t, increasing with t
</span>        <span class="n">x</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="nf">get_sample_from_protein</span><span class="p">(</span><span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">)</span> <span class="c1"># batch samples
</span>
        <span class="n">x_eps</span><span class="p">,</span> <span class="n">R_eps</span> <span class="o">=</span> <span class="nf">sample_from_se3_gaussian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span> <span class="c1"># noised samples
</span>
        <span class="n">v_tar</span> <span class="o">=</span> <span class="nf">se3_score_normal</span><span class="p">(</span><span class="n">x_eps</span><span class="p">,</span> <span class="n">R_eps</span><span class="p">,</span> <span class="n">x_tar</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">R_tar</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="n">std</span><span class="p">)</span> <span class="c1"># estimate scores of noised samples
</span>
        <span class="n">v_pred</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">x_eps</span><span class="p">,</span> <span class="n">R_eps</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="c1"># predicted scores from model
</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">std</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(((</span><span class="n">v_pred</span> <span class="o">-</span> <span class="n">v_tar</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">).</span><span class="nf">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># score matching loss
</span>        <span class="n">loss_trj</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">loss_trj</span><span class="p">,</span> <span class="n">loss</span><span class="p">.</span><span class="nf">mean</span><span class="p">().</span><span class="nf">detach</span><span class="p">()[</span><span class="bp">None</span><span class="p">]),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Backward pass and optimization
</span>        <span class="n">optimizer</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>
        <span class="n">loss</span><span class="p">.</span><span class="nf">mean</span><span class="p">().</span><span class="nf">backward</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>

    <span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">loss_trj</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>

    <span class="c1"># torch.save(model.state_dict(), 'model.pt')</span></code></pre></figure> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">if</span> <span class="ow">not</span> <span class="n">retrain</span><span class="p">:</span>
  <span class="n">model</span> <span class="o">=</span> <span class="nc">NaiveSE3DiffusionModel2</span><span class="p">()</span>
  <span class="n">model</span><span class="p">.</span><span class="nf">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="sh">'</span><span class="s">model.pt</span><span class="sh">'</span><span class="p">))</span>
<span class="n">H</span><span class="p">,</span> <span class="n">__</span> <span class="o">=</span> <span class="nf">sample_se3</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">get_sample_from_protein</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
<span class="n">H2</span><span class="p">,</span> <span class="n">__</span> <span class="o">=</span> <span class="nf">sample_se3</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">get_sample_from_protein</span><span class="p">,</span> <span class="n">noise_on</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>

<span class="n">H</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">H</span><span class="p">,</span> <span class="n">H2</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">colors</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">1101</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">colors</span><span class="p">[:</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">colors</span><span class="p">[</span><span class="mi">1000</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">scene</span> <span class="o">=</span> <span class="nf">visualize_grasps</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">H</span><span class="p">,</span> <span class="n">prot</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">.</span><span class="nf">numpy</span><span class="p">(),</span> <span class="n">show</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span></code></pre></figure> <iframe src="/assets/img/posts/se3diff/ex3sample1.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">colors</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">H</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">colors</span><span class="p">[:</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">colors</span><span class="p">[</span><span class="mi">1000</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">scene</span> <span class="o">=</span> <span class="nf">visualize_grasps</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">H</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">.</span><span class="nf">numpy</span><span class="p">(),</span><span class="n">show</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">display</span><span class="p">.</span><span class="nf">display</span><span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="nf">show</span><span class="p">())</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Green is the grund truth</span><span class="sh">'</span><span class="p">)</span></code></pre></figure> <iframe src="/assets/img/posts/se3diff/ex3sample2.html" frameborder="0" scrolling="yes" height="800px" width="100%" style="border: 1px dashed grey;"></iframe> <h3 id="5-final-remarks">5. Final remarks</h3> <hr> <p>The SO(3) data can be transformed to the corresponding vector (axis angle) representation via the Log_map. Approximating SO(3) is equivalent to approximating the vector representation, at least in this notebook.</p> <p>Note here that we were doing a single SE(3) distribution, instead of modeling a set or an ordered set of SE(3) distributions, like proteins, robot joints. Therefore, the model is just a bunch of Linear layers. If that’s the problem we are interested, we are modeling the SE(3)\(^N\) distribution, where the interactions between each SE(3) will be critical, the model needs to be SE(3)-equivariant to respect the relative roto-translational information between SE(3)\(^N\). Such model was used in AlphaFold2 (IPA) or Rosettafold (SE(3)-Transformer).</p> <p>Hope you find this tutorial interesting and useful.</p> <h3 id="6-references">6. References</h3> <ol> <li>Urain et al, Learning Diffusion Models in SE(3) for 6DoF Grasp Pose Generation, (<a href="https://www.mirmi.tum.de/fileadmin/w00byb/mirmi/_my_direct_uploads/ICRA2023_Geometry_workshop.pdf" rel="external nofollow noopener" target="_blank">link</a>)</li> <li>Sola et al, A micro Lie theory for state estimation in robotics, (<a href="https://arxiv.org/abs/1812.01537" rel="external nofollow noopener" target="_blank">link</a>)</li> <li>Yim et al, SE(3) diffusion model with application to protein backbone generation, (<a href="https://arxiv.org/abs/2302.02277" rel="external nofollow noopener" target="_blank">link</a>)</li> </ol> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Yen-Lin Chen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: June 27, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>