<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>EPI-EPMP Multitasking Model | Yen-Lin Chen</title> <meta name="author" content="Yen-Lin Chen"> <meta name="description" content="Implementation of Del Vecchio et al. " neural message passing for joint paratope-epitope prediction> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://jipq6175.github.io/blog/2023/epiepmp/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Yen-Lin </span>Chen</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blogs<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">EPI-EPMP Multitasking Model</h1> <p class="post-meta">March 5, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/reading"> <i class="fas fa-hashtag fa-sm"></i> reading</a>   <a href="/blog/tag/coding"> <i class="fas fa-hashtag fa-sm"></i> coding</a>   <a href="/blog/tag/fitting"> <i class="fas fa-hashtag fa-sm"></i> fitting</a>     ·   <a href="/blog/category/models"> <i class="fas fa-tag fa-sm"></i> models</a>   </p> </header> <article class="post-content"> <p>The EPI-EPMP multitasking model was proposed by <a href="https://arxiv.org/abs/2106.00757" rel="external nofollow noopener" target="_blank">this paper</a>. The model is based on message-passing neural networks; it takes antibody and antigen structures as input and predicts the paratope on the antibody and epitope on the antigen. The model architecture is shown below, which is the Fig. 2 of the original paper.</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/epiepmp/epiepmp-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/epiepmp/epiepmp-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/epiepmp/epiepmp-1400.webp"></source> <img src="/assets/img/posts/epiepmp/epiepmp.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p>The model uses 2 different graph neural networks to process the antibody and antigen structure separately to get node embeddings for each residues. Then these nodes were used to construct a bipartite graph, similar to the old recommender system. The antigen and antibody node embeddings are passed around with graph attentional network (<a href="https://arxiv.org/abs/1710.10903" rel="external nofollow noopener" target="_blank">GAT</a>) to obtain a final embedding for predicting binding probability of both paratopes and epitopes.</p> <p>The benefit of such model is that it does not assume or sample relative orientations between antibody and antigen, which can be quite computationally expensive. It aims to do message-passing between antigen and antibody residues and determines the epitope and paratope from the mutual structural context.</p> <p>I will use <code class="language-plaintext highlighter-rouge">pyotrch-geometric</code>(<a href="https://www.pyg.org/" rel="external nofollow noopener" target="_blank">PyG</a>) to build the batched data and EPI-EPMP model.</p> <hr> <h3 id="1-data-graph-pairing">1. Data: Graph Pairing</h3> <p>For the model, one data point is one <code class="language-plaintext highlighter-rouge">(antibody, antigen)</code> pair. We have to build a paired data with minibatching. The tricky part is that antibody and antigen might have different number of residues, so we need to first take care of them separately.</p> <p>Let’s assume that one can transform a protein structure data (i.e. atomic coordinates, PDBs) into a featurized graph <code class="language-plaintext highlighter-rouge">G</code> with node feature <code class="language-plaintext highlighter-rouge">x</code>, edge index <code class="language-plaintext highlighter-rouge">edge_index</code>. The <a href="https://graphein.ai/" rel="external nofollow noopener" target="_blank">Graphein</a> package is one of the cool packages for this purpose. The following <code class="language-plaintext highlighter-rouge">AbAgPair</code> data class builds the paired graph:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td> <td class="code"><pre><span class="kn">from</span> <span class="n">torch_geometric.data</span> <span class="kn">import</span> <span class="n">Data</span>

<span class="k">class</span> <span class="nc">AbAgPair</span><span class="p">(</span><span class="n">Data</span><span class="p">):</span> 
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">antigen</span><span class="p">,</span> <span class="n">antibody</span><span class="p">):</span> 
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        
        <span class="c1"># antigen: add prefix 'ag' to all fields
</span>        <span class="n">ag_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">edge_index</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">x</span><span class="sh">'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">antigen</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> 
            <span class="k">for</span> <span class="n">ag_attr</span> <span class="ow">in</span> <span class="n">ag_attrs</span><span class="p">:</span> 
                <span class="nf">setattr</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="s">ag_</span><span class="si">{</span><span class="n">ag_attr</span><span class="si">}</span><span class="sh">'</span><span class="p">,</span> <span class="nf">getattr</span><span class="p">(</span><span class="n">antigen</span><span class="p">,</span> <span class="n">ag_attr</span><span class="p">))</span>
        
        <span class="c1"># antibody: add prefix 'ab' to all fields
</span>        <span class="n">ab_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">edge_index</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">x</span><span class="sh">'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">antibody</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span> 
            <span class="k">for</span> <span class="n">ab_attr</span> <span class="ow">in</span> <span class="n">ab_attrs</span><span class="p">:</span> 
                <span class="nf">setattr</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="s">ab_</span><span class="si">{</span><span class="n">ab_attr</span><span class="si">}</span><span class="sh">'</span><span class="p">,</span> <span class="nf">getattr</span><span class="p">(</span><span class="n">antibody</span><span class="p">,</span> <span class="n">ab_attr</span><span class="p">))</span>
    
    <span class="c1"># incremental operation: for minibatching
</span>    <span class="c1"># the index incremental follows # of nodes of antibody or antigen
</span>    <span class="k">def</span> <span class="nf">__inc__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="sh">'</span><span class="s">ag_edge_index</span><span class="sh">'</span><span class="p">:</span> <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">ag_x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="sh">'</span><span class="s">ab_edge_index</span><span class="sh">'</span><span class="p">:</span> <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">ab_x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="nf">super</span><span class="p">().</span><span class="nf">__inc__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>Now given a list of <code class="language-plaintext highlighter-rouge">AbAgPair</code> objects, we can build the data loader with antigen-antibody pairs.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td> <td class="code"><pre><span class="kn">from</span> <span class="n">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="n">torch_geometric.loader</span> <span class="kn">import</span> <span class="n">DataLoader</span>

<span class="n">datalist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">pairname</span> <span class="ow">in</span> <span class="nf">tqdm</span><span class="p">(</span><span class="n">pairnames</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">desc</span><span class="o">=</span><span class="sh">'</span><span class="s">Loading Ab-Ag Pairs</span><span class="sh">'</span><span class="p">):</span> 
        <span class="n">g_ag</span><span class="p">,</span> <span class="n">g_ab</span> <span class="o">=</span> <span class="p">...,</span> <span class="p">...</span> <span class="c1"># the graphs for pairing 
</span>        <span class="n">paired_data</span> <span class="o">=</span> <span class="nc">AbAgPair</span><span class="p">(</span><span class="n">g_ag</span><span class="p">,</span> <span class="n">g_ab</span><span class="p">)</span>
        <span class="n">datalist</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">paired_data</span><span class="p">)</span>

    <span class="c1"># train and test splitting
</span>    <span class="n">train_data</span><span class="p">,</span> <span class="n">test_data</span> <span class="o">=</span> <span class="nf">train_test_split</span><span class="p">(</span><span class="n">datalist</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
    
    <span class="c1"># dataloaders: 
</span>    <span class="c1"># Need to keep track of the batch index for both antibody and antigen separately
</span>    <span class="c1"># The batched data will contain additional fields: 'ag_x_batch' and 'ab_x_batch'
</span>    <span class="n">train_dataloader</span> <span class="o">=</span> <span class="nc">DataLoader</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">follow_batch</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">ag_x</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">ab_x</span><span class="sh">'</span><span class="p">])</span>
    <span class="n">test_dataloader</span> <span class="o">=</span> <span class="nc">DataLoader</span><span class="p">(</span><span class="n">test_data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">follow_batch</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">ag_x</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">ab_x</span><span class="sh">'</span><span class="p">])</span>
    
</pre></td> </tr></tbody></table></code></pre></figure> <hr> <h3 id="2-model-epi-epmp">2. Model: EPI-EPMP</h3> <p>Now the data and loader is constructed. The model is built based on how it was architected in the figure above.</p> <h4 id="21-model-architecture">2.1 Model Architecture</h4> <p>The model needs to process information differently for <code class="language-plaintext highlighter-rouge">ab_</code> and <code class="language-plaintext highlighter-rouge">ag_</code>.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre></td> <td class="code"><pre><span class="kn">import</span> <span class="n">torch</span>

<span class="kn">from</span> <span class="n">torch_geometric.nn</span> <span class="kn">import</span> <span class="n">GATConv</span><span class="p">,</span> <span class="n">GCNConv</span><span class="p">,</span> <span class="n">Linear</span>
<span class="kn">from</span> <span class="n">torch.nn</span> <span class="kn">import</span> <span class="n">Sequential</span><span class="p">,</span> <span class="n">Tanh</span><span class="p">,</span> <span class="n">BatchNorm1d</span>

<span class="c1"># EPI-EPMP Multitasking Model
</span><span class="k">class</span> <span class="nc">EpiEPMP</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span> 
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">node_attr_dim</span><span class="p">,</span> <span class="n">edge_attr_dim</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">,</span> <span class="n">h1_dim</span><span class="p">,</span> <span class="n">h2_dim</span><span class="p">,</span> <span class="n">share_weight</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dropout</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">heads</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span> 
        <span class="nf">super</span><span class="p">(</span><span class="n">EpiEPMP</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">node_attr_dim</span> <span class="o">=</span> <span class="n">node_attr_dim</span>
        <span class="n">self</span><span class="p">.</span><span class="n">edge_attr_dim</span> <span class="o">=</span> <span class="n">edge_attr_dim</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dim</span> <span class="o">=</span> <span class="n">hidden_dim</span>
        <span class="n">self</span><span class="p">.</span><span class="n">h1_dim</span> <span class="o">=</span> <span class="n">h1_dim</span> <span class="c1"># dim after the first gnn
</span>        <span class="n">self</span><span class="p">.</span><span class="n">h2_dim</span> <span class="o">=</span> <span class="n">h2_dim</span> <span class="c1"># dim after the bipartite message passing
</span>        <span class="n">self</span><span class="p">.</span><span class="n">share_weight</span> <span class="o">=</span> <span class="n">share_weight</span> <span class="c1"># Should model weights be shared between Ag and Ab?
</span>        <span class="n">self</span><span class="p">.</span><span class="n">dropout</span> <span class="o">=</span> <span class="n">dropout</span>
        <span class="n">self</span><span class="p">.</span><span class="n">heads</span> <span class="o">=</span> <span class="n">heads</span>
        
        <span class="c1"># 2 layers antigen GCN (2-hop basically)
</span>        <span class="n">self</span><span class="p">.</span><span class="n">ag_gnn1</span> <span class="o">=</span> <span class="nc">GCNConv</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node_attr_dim</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">hidden_dim</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">ag_gnn2</span> <span class="o">=</span> <span class="nc">GCNConv</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">h1_dim</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">share_weight</span><span class="p">:</span> 
            <span class="c1"># if weights are shared, 2 layers of antibody GCN are identical with antigen GCN
</span>            <span class="n">self</span><span class="p">.</span><span class="n">ab_gnn1</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">ag_gnn1</span>
            <span class="n">self</span><span class="p">.</span><span class="n">ab_gnn2</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">ag_gnn2</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="c1"># or the antibody uses new GCNs
</span>            <span class="n">self</span><span class="p">.</span><span class="n">ab_gnn1</span> <span class="o">=</span> <span class="nc">GCNConv</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">node_attr_dim</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">hidden_dim</span><span class="p">)</span>
            <span class="n">self</span><span class="p">.</span><span class="n">ab_gnn2</span> <span class="o">=</span> <span class="nc">GCNConv</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">h1_dim</span><span class="p">)</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">ag_bnorm1</span> <span class="o">=</span> <span class="nc">BatchNorm1d</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dim</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">ag_bnorm2</span> <span class="o">=</span> <span class="nc">BatchNorm1d</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">h1_dim</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">ab_bnorm1</span> <span class="o">=</span> <span class="nc">BatchNorm1d</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dim</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">ab_bnorm2</span> <span class="o">=</span> <span class="nc">BatchNorm1d</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">h1_dim</span><span class="p">)</span>
        
        <span class="c1"># The GATs for the bipartite graph
</span>        <span class="n">self</span><span class="p">.</span><span class="n">bp_gnn1</span> <span class="o">=</span> <span class="nc">GATConv</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">h1_dim</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="n">heads</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">heads</span><span class="p">,</span> <span class="n">concat</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">dropout</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">dropout</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">bp_gnn2</span> <span class="o">=</span> <span class="nc">GATConv</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dim</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">heads</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">h2_dim</span><span class="p">,</span> <span class="n">heads</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">heads</span><span class="p">,</span> <span class="n">concat</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dropout</span><span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="n">dropout</span><span class="p">)</span>
        
        <span class="c1"># antigen prediction head
</span>        <span class="n">self</span><span class="p">.</span><span class="n">ag_classifier</span> <span class="o">=</span> <span class="nc">Sequential</span><span class="p">(</span><span class="nc">Linear</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">h1_dim</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">h2_dim</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">hidden_dim</span><span class="p">),</span> 
                                        <span class="nc">Tanh</span><span class="p">(),</span>
                                        <span class="nc">Linear</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        
        <span class="c1"># Classifier can be shared or not
</span>        <span class="c1"># The same as the GCN's
</span>        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">share_weight</span><span class="p">:</span> 
            <span class="n">self</span><span class="p">.</span><span class="n">ab_classifier</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">ag_classifier</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">self</span><span class="p">.</span><span class="n">ab_classifier</span> <span class="o">=</span> <span class="nc">Sequential</span><span class="p">(</span><span class="nc">Linear</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">h1_dim</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="n">h2_dim</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">hidden_dim</span><span class="p">),</span> 
                                            <span class="nc">Tanh</span><span class="p">(),</span>
                                            <span class="nc">Linear</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    
    
    
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">ag_x</span><span class="p">,</span> <span class="n">ag_edge_index</span><span class="p">,</span> <span class="n">ag_x_batch</span><span class="p">,</span> \
                      <span class="n">ab_x</span><span class="p">,</span> <span class="n">ab_edge_index</span><span class="p">,</span> <span class="n">ab_x_batch</span><span class="p">):</span>
        
        <span class="c1"># antigen gnn + batchnorm
</span>        <span class="n">ag_h1</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">ag_bnorm1</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">tanh</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">ag_gnn1</span><span class="p">(</span><span class="n">ag_x</span><span class="p">,</span> <span class="n">ag_edge_index</span><span class="p">)))</span>
        <span class="n">ag_h1</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">ag_bnorm2</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">tanh</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">ag_gnn2</span><span class="p">(</span><span class="n">ag_h1</span><span class="p">,</span> <span class="n">ag_edge_index</span><span class="p">)))</span>
        
        <span class="c1"># antibody gnn + batchnorm
</span>        <span class="n">ab_h1</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">ab_bnorm1</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">tanh</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">ab_gnn1</span><span class="p">(</span><span class="n">ab_x</span><span class="p">,</span> <span class="n">ab_edge_index</span><span class="p">)))</span>
        <span class="n">ab_h1</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">ab_bnorm2</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">tanh</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">ab_gnn2</span><span class="p">(</span><span class="n">ab_h1</span><span class="p">,</span> <span class="n">ab_edge_index</span><span class="p">)))</span>
        
        <span class="c1"># bipartite construction
</span>        <span class="n">x</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">,</span> <span class="n">ag_index</span><span class="p">,</span> <span class="n">ab_index</span> <span class="o">=</span> <span class="nf">bipartite</span><span class="p">(</span><span class="n">ag_h1</span><span class="p">,</span> <span class="n">ag_x_batch</span><span class="p">,</span> <span class="n">ab_h1</span><span class="p">,</span> <span class="n">ab_x_batch</span><span class="p">)</span>
        <span class="n">h2</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tanh</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">bp_gnn1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">))</span>
        <span class="n">h2</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tanh</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="nf">bp_gnn2</span><span class="p">(</span><span class="n">h2</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">))</span>
        <span class="n">ag_h2</span><span class="p">,</span> <span class="n">ab_h2</span> <span class="o">=</span> <span class="n">h2</span><span class="p">[</span><span class="n">ag_index</span><span class="p">],</span> <span class="n">h2</span><span class="p">[</span><span class="n">ab_index</span><span class="p">]</span>
        
        <span class="c1"># concat skip connection and clasifier heads
</span>        <span class="n">ag_out</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">ag_classifier</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">ag_h1</span><span class="p">,</span> <span class="n">ag_h2</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">ab_out</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">ab_classifier</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">ab_h1</span><span class="p">,</span> <span class="n">ab_h2</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">ag_out</span><span class="p">,</span> <span class="n">ag_h1</span><span class="p">,</span> <span class="n">ag_h2</span><span class="p">,</span> <span class="n">ab_out</span><span class="p">,</span> <span class="n">ab_h1</span><span class="p">,</span> <span class="n">ab_h2</span>
</pre></td> </tr></tbody></table></code></pre></figure> <h4 id="22-the-bipartite-graph">2.2 The Bipartite Graph</h4> <p>The bipartite graph is constructed in such way that every antigen node has edges connecting to all antibody nodes and vise versa. The antigen/antibody nodes themselves don’t necessarily need to be fully connected in the bipartite because such locality was captured in the original protein graph already. In the bipartite, we just want the model to pass messages between antigen and antibody.</p> <p>The bipartite is built with the minibatched paired data, i.e. <code class="language-plaintext highlighter-rouge">batch_size</code> bipartites are built for each minibatch, so <code class="language-plaintext highlighter-rouge">ag_x_batch</code> and <code class="language-plaintext highlighter-rouge">ab_x_batch</code> are used to keep track which bipartite is which.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td> <td class="code"><pre><span class="kn">import</span> <span class="n">torch</span>
<span class="kn">from</span> <span class="n">torch_geometric.utils</span> <span class="kn">import</span> <span class="n">add_self_loops</span>


<span class="c1"># create bipartite using index and attributes
# with device consistent tensors
</span><span class="k">def</span> <span class="nf">bipartite</span><span class="p">(</span><span class="n">ag_x</span><span class="p">,</span> <span class="n">ag_x_batch</span><span class="p">,</span> <span class="n">ab_x</span><span class="p">,</span> <span class="n">ab_x_batch</span><span class="p">):</span> 
    
    <span class="k">assert</span> <span class="n">ag_x</span><span class="p">.</span><span class="n">device</span> <span class="o">==</span> <span class="n">ag_x_batch</span><span class="p">.</span><span class="n">device</span> <span class="o">==</span> <span class="n">ab_x</span><span class="p">.</span><span class="n">device</span> <span class="o">==</span> <span class="n">ab_x_batch</span><span class="p">.</span><span class="n">device</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">ag_x</span><span class="p">.</span><span class="n">device</span>
    
    <span class="c1"># node attr and edge index
</span>    <span class="n">x</span><span class="p">,</span> <span class="n">edge_index</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nb">float</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">),</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nb">long</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

    <span class="c1"># antigen and antibody index for later retreval of the matrix
</span>    <span class="n">ag_index</span><span class="p">,</span> <span class="n">ab_index</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nb">long</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">),</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nb">long</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    
    <span class="c1"># getting the unique batch index for the antibody and antigens
</span>    <span class="n">ag_batch_unique</span><span class="p">,</span> <span class="n">ab_batch_unique</span> <span class="o">=</span> <span class="n">ag_x_batch</span><span class="p">.</span><span class="nf">unique</span><span class="p">(),</span> <span class="n">ab_x_batch</span><span class="p">.</span><span class="nf">unique</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">ab_batch_unique</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ag_batch_unique</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># creating the bipartite following the batch index
</span>    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ag_batch_unique</span><span class="p">:</span> 
        <span class="n">idx_ag</span><span class="p">,</span> <span class="n">idx_ab</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">ag_x_batch</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">torch</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">ab_x_batch</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">n_ag</span><span class="p">,</span> <span class="n">n_ab</span> <span class="o">=</span> <span class="n">idx_ag</span><span class="p">.</span><span class="nf">sum</span><span class="p">(),</span> <span class="n">idx_ab</span><span class="p">.</span><span class="nf">sum</span><span class="p">()</span>
        
        <span class="c1"># keeping the offset
</span>        <span class="n">offset</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># antigen
</span>        <span class="n">ag</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">n_ag</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nb">long</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">ag_index</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">ag_index</span><span class="p">,</span> <span class="n">ag</span><span class="p">])</span>
        <span class="c1"># antibody
</span>        <span class="n">ab</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">n_ag</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">n_ag</span> <span class="o">+</span> <span class="n">n_ab</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nb">long</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="n">ab_index</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">ab_index</span><span class="p">,</span> <span class="n">ab</span><span class="p">])</span>
        
        <span class="c1"># construct the edge_index
</span>        <span class="n">edge_index</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">edge_index</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">ag</span><span class="p">.</span><span class="nf">repeat_interleave</span><span class="p">(</span><span class="n">n_ab</span><span class="p">).</span><span class="nf">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">ab</span><span class="p">.</span><span class="nf">repeat</span><span class="p">(</span><span class="n">n_ag</span><span class="p">).</span><span class="nf">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">edge_index</span> <span class="o">=</span> <span class="nf">add_self_loops</span><span class="p">(</span><span class="n">edge_index</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># construct the node feature
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">ag_x</span><span class="p">[</span><span class="n">idx_ag</span><span class="p">],</span> <span class="n">ab_x</span><span class="p">[</span><span class="n">idx_ab</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">edge_index</span><span class="p">,</span> <span class="n">ag_index</span><span class="p">,</span> <span class="n">ab_index</span>
</pre></td> </tr></tbody></table></code></pre></figure> <hr> <h3 id="3-in-batch-sampling">3. In-Batch Sampling</h3> <p>Since paratope and epitope residues are generally less than 10 \% of the number of residues (nodes) in the protein (graph). One can scale the loss function to account for the label imbalance. I chose to do the balance sampling while leaving equal weighting of the paratope and epitope prediction losses. The in-batch sampling function is as follows.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td> <td class="code"><pre><span class="kn">import</span> <span class="n">torch</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">sample_balanced_indices</span><span class="p">(</span><span class="n">y</span><span class="p">):</span> 
    <span class="n">pos_ix</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">nonzero</span><span class="p">(</span><span class="n">y</span><span class="p">).</span><span class="nf">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="nf">cpu</span><span class="p">()</span>
    <span class="n">n_pos</span> <span class="o">=</span> <span class="n">pos_ix</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">neg_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">nonzero</span><span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">).</span><span class="nf">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">neg_ix</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">neg_indices</span><span class="p">.</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">numpy</span><span class="p">(),</span> <span class="nf">min</span><span class="p">(</span><span class="n">n_pos</span><span class="p">,</span> <span class="n">neg_indices</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">pos_ix</span><span class="p">,</span> <span class="n">neg_ix</span><span class="p">))</span>

<span class="c1"># For each batch index, sample balanced labels of the negative (non-epitope) nodes
</span><span class="k">def</span> <span class="nf">in_batch_sampling</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">batch</span><span class="p">):</span> 

    <span class="n">ubatch</span> <span class="o">=</span> <span class="n">batch</span><span class="p">.</span><span class="nf">unique</span><span class="p">()</span>
    <span class="n">idx</span><span class="p">,</span> <span class="n">sampled_batch</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nb">long</span><span class="p">),</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nb">long</span><span class="p">)</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># keeping track of the # of nodes as offset for different batch index
</span>    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">ubatch</span><span class="p">:</span> 
        <span class="n">yb</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">batch</span> <span class="o">==</span> <span class="n">b</span><span class="p">]</span>

        <span class="n">ix</span> <span class="o">=</span> <span class="nf">sample_balanced_indices</span><span class="p">(</span><span class="n">yb</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">idx</span><span class="p">,</span> <span class="n">ix</span><span class="p">])</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="n">yb</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
 
    <span class="k">return</span> <span class="n">idx</span><span class="p">,</span> <span class="n">sampled_batch</span> 
</pre></td> </tr></tbody></table></code></pre></figure> <hr> <h3 id="4-observations-and-discussions">4. Observations and Discussions</h3> <h4 id="41-from-the-paper">4.1 From the Paper</h4> <p>The authors demonstrated good validation case with the SARS-COV-2 spike protein and a corresponding antibody that targets it.</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/epiepmp/sars-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/epiepmp/sars-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/epiepmp/sars-1400.webp"></source> <img src="/assets/img/posts/epiepmp/sars.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <h4 id="42-performances">4.2 Performances</h4> <p>I experiemnted with self-generated structural features, i.e. <code class="language-plaintext highlighter-rouge">ag_x</code> and <code class="language-plaintext highlighter-rouge">ab_x</code> and achieved similar performances as reported in the paper.</p> <p>For antibody paratopes: <code class="language-plaintext highlighter-rouge">AUROC = 0.800 (0.966)</code>, <code class="language-plaintext highlighter-rouge">AUPRC = 0.551 (0.752)</code>. The bracketed values were the reported values. The discrepancy is that the authors only use the CDRs regions to feed into the model where as I was using the whole antibody, including the framework regions, which makes the paratope task a bit challenging as the labels are much more imbalanced and noises or confusions might arise from the loop regions on top of the CDR loops. However, genrally, antibody CDRs can be determined purely from sequences, so there is so surprise that the paratopes are easier to predict (middle of the CDR loops of H3 and L3). The left figure below is the predicted paratopes among different anibody fabs.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/epiepmp/paratopes-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/epiepmp/paratopes-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/epiepmp/paratopes-1400.webp"></source> <img src="/assets/img/posts/epiepmp/paratopes.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/epiepmp/truth-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/epiepmp/truth-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/epiepmp/truth-1400.webp"></source> <img src="/assets/img/posts/epiepmp/truth.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/epiepmp/pred-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/epiepmp/pred-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/epiepmp/pred-1400.webp"></source> <img src="/assets/img/posts/epiepmp/pred.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>For antigen epitopes: <code class="language-plaintext highlighter-rouge">AUROC = 0.798 (0.710)</code>, <code class="language-plaintext highlighter-rouge">AUPRC = 0.319 (0.277)</code>. The middle figure is the ground truth and right is the model prediction of one sample in the testing set with anitgen and antibody shown in blue and green with different probabilities overlayed on the surfaces using <a href="https://pymol.org/2/" rel="external nofollow noopener" target="_blank">PyMol</a>.</p> <p>It is usually interesting to look under the hood what the model learned. Here are the PCA plots for antigen and antibody node embeddings (<code class="language-plaintext highlighter-rouge">ag_h1</code> and <code class="language-plaintext highlighter-rouge">ab_h1</code>) colored by the node degree. There is no obvious correlation between embeddings and node degree because the model was trained in such way that it focused on structural context, i.e. node features while still taking local neighborhood into account.</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/epiepmp/pca-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/epiepmp/pca-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/epiepmp/pca-1400.webp"></source> <img src="/assets/img/posts/epiepmp/pca.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <h4 id="43-efficiency">4.3 Efficiency</h4> <p>Generally, the training took about 48 GPU-hrs for a few k of data and epochs. The inference took ~ <code class="language-plaintext highlighter-rouge">2s</code>. The computationally expensive part was the featurization.</p> <p>The minibatch might bags LARGE antigens with &gt;500 residues, and might consume large memory or even cause <code class="language-plaintext highlighter-rouge">RuntimeError: CUDA error: out of memory</code>.</p> <h4 id="44-some-thoughts">4.4 Some Thoughts</h4> <p>When the antibody and antigen complex is formed for cryoEM or X-ray cystallography, the conformations of both changed. The side chains might pertrude and all the structural context might differ from the original free antibody or antigen. Using the bound complex to predict the interfaces or epitopes might suffer information leakage that undermine the model’s generalizability to free antigens for antibody designs or applications.</p> <p>This EPI-EPMP model is not a conditional model. It does message passing between antigen and antibodies but the authors did not show that if the model learned the conditional probability <code class="language-plaintext highlighter-rouge">P(epiotpe | paratope)</code> or independent probabilities <code class="language-plaintext highlighter-rouge">P(epitope) P(paratope)</code>. I was convinced that the latter was the case, meaning that if one pairs any antibody to the same antigen, the epitope prediction does not vary, which might limit the real-world use case as people care more about where different antibodies bind to a certain target. A deeper look into the GAT attentional weight in the bipartite confirms that the attentional edges (or soft edges) are very sparse, i.e. the model might as well use an epitope node embedding ONLY rather than paying attention to ANY antibody nodes. I call this as attention collapse, where the dense attentional edges collaped to self-attention after training.</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/epiepmp/attention-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/epiepmp/attention-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/epiepmp/attention-1400.webp"></source> <img src="/assets/img/posts/epiepmp/attention.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p>One solution to this could be forcing information flow into the epitope prediction.</p> <p>Sometimes the epitopes span a large portion on the antigen surface; further narrowing down of the epitopes might require force-field (physical) modeling of the docking free energies but at least the model has ruled out quite a large set of potential patches.</p> <hr> <p>Here is the repo of my implementation of the EPI-EPMP multitasking model.</p> <p><a href="https://github.com/jipq6175/Epi_EPMP_Pytorch" rel="external nofollow noopener" target="_blank">EPI_EPMP_Pytorch</a></p> <hr> <h3 id="reference">Reference</h3> <ol> <li>Alice Del Vecchio, Andreea Deac, Pietro Liò, Petar Veličković, Neural message passing for joint paratope-epitope prediction, https://arxiv.org/abs/2106.00757</li> </ol> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Yen-Lin Chen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: June 27, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>