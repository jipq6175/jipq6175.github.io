<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Playing with Generative Flow Matching Model | Yen-Lin Chen</title> <meta name="author" content="Yen-Lin Chen"> <meta name="description" content="Flow matching learning notes on continuous data, 2D and Image"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://jipq6175.github.io/blog/2025/flow_matching_1/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Yen-Lin </span>Chen</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blogs<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Playing with Generative Flow Matching Model</h1> <p class="post-meta">January 29, 2025</p> <p class="post-tags"> <a href="/blog/2025"> <i class="fas fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/reading"> <i class="fas fa-hashtag fa-sm"></i> reading</a>   <a href="/blog/tag/generating"> <i class="fas fa-hashtag fa-sm"></i> generating</a>   <a href="/blog/tag/coding"> <i class="fas fa-hashtag fa-sm"></i> coding</a>     ·   <a href="/blog/category/models"> <i class="fas fa-tag fa-sm"></i> models</a>   </p> </header> <article class="post-content"> <p>Previously, we were playing with score-based diffusion model, which generates data from noise prior by predicting the scores, \(\nabla_x\log p(x)\), and trained using forward SDE. Flow-based model, on the other hand, generates the data by predicting the flow vector fields that warps any prior distribution to the unknown data distribution and is a more general formalism and easier to train in practice. I will explore flow matching in 2 parts, continuous and discrete.</p> <p>In the continuous case, flow matching model aims to construct a time-dependent vector field \(v: [0, 1] \times \mathbf{R}^d \to \mathbf{R}^d\) to reshape a simple (or known sample-able) prior distribution \(p_0\) into a more complicated and unknown distribution \(p_1\). Typically, \(p_0\) and \(p_1\) are noise and data distributions respectively but \(p_0\) can actually be any prior. We let \(p_t(x)\) be the probability density path at time \(t\) and \(u_t(x)\) be the corresponding vector field, which generates \(p_t(x)\). Once we know \(u_t(x)\), we can generate a sample from prior \(x_0\), use \(u_0(x_0)\) to find \(x_t\) and use \(u_t(x_t)\) to find \(x_{2t}\) etc until we recover the data \(x_1\). So the flow matching objective is</p> \[\mathcal{L}_{FM}(\theta) = \mathbf{E}_{t,p_t(x)}||v_{t, \theta}(x) - u_t(x)||^2\] <p>where \(v_{t, \theta}(x)\) is a neural network regressing on the flow vector field \(u_t(x)\) at all time \(t\).</p> <p>We don’t have a close form of \(u_t\) but we can construct \(p_t\) and \(u_t\) <strong>per sample</strong> \(x_1 \sim q(x_1) \sim p_1\) (conditioned on a data sample), i.e. the conditional probability path \(p_t(x|x_1)\) will satisfy the following conditions at the boundaries of time: \(t=0\) and \(t=1\)</p> <ul> <li> \[p_0(x|x_1) \sim \text{prior or noise} \sim p_0(x) \sim \mathcal{N}(x|0, I)\] </li> <li> \[p_1(x|x_1) \sim \delta(x_1) \sim \mathcal{N}(x|x_1, \sigma^2I), \sigma\approx0\] </li> </ul> <p>From these conditional probability endpoints, we can construct conditional probability path \(p_t(x|x_1)\) and conditional vector field \(u_t(x|x_1)\). The conditional flow matching objective is then</p> \[\mathcal{L}_{CFM}(\theta) = \mathbf{E}_{t, q(x_1), p_t(x|x1)}||v_{t,\theta}(x) - u_t(x|x_1)||^2\] <p>where \(v_{t, \theta}(x)\) is a neural network. Previous work has shown that these 2 objectives or loss functions are equivalent in the sense that optimizing them will result in the same weight, or they have the same gradient, i.e.</p> \[\nabla_\theta \mathcal{L}_{FM}(\theta) = \nabla_\theta \mathcal{L}_{CFM}(\theta)\] <p><br></p> <p>At training time, given \(p_0\) and training data from \(p_1\), we do the following:</p> <ol> <li>Sample \(t\in[0, 1]\)</li> <li>Sample data point \(x_1\sim p_1(x) \sim q(x)\)</li> <li>Sample \(x \sim p_t(x \mid x_1)\)</li> <li>Compute corresponding conditional vector field \(u_t(x \mid x_1)\)</li> <li>Use neural network \(v_{t,\theta}(x)\) to regress on the conditional vector field.</li> </ol> <p><br></p> <p>So what is this conditional probability path \(p_t(x \mid x_1)\) and conditional vector field \(u_t(x \mid x_1)\)?</p> <p>The conditional flow matching objective works with <strong>ANY</strong> choice of conditional path and conditional vector field. One way to construct \(p_t(x \mid x_1)\) is to use Gaussian distribution with time-varying mean and variances:</p> \[p_t(x \mid x_1) = \mathcal{N}(x \mid \mu_t(x_1), \sigma_t(x_1)^2 I)\] <p>where \(\mu_t(x_1)\) satisfies</p> \[\begin{align*} \mu_0(x_1) = 0 \\ \mu_1(x_1) = x_1 \end{align*}\] <p>and \(\sigma_t(x_1)\) satisfies</p> \[\begin{align*} \sigma_0(x_1) = 1 \\ \sigma_1(x_1) = \sigma_{min} \end{align*}\] <p>And the unique vector field we are trying to regress to is</p> \[u_t(x \mid x_1) = \frac{\sigma'_t(x_1)}{\sigma_t(x_1)}[x - \mu_t(x_1)] + \mu'_t(x_1)\] <p>If we <strong>choose</strong> or <strong>design</strong> the conditional probability path to be Gaussian, then we can easily sample \(p_t(x \mid x_1)\) and \(u_t(x \mid x_1)\) will have exact form. Other formulations of \(p_t(x \mid x_1)\) will also work but might not have easy-to-compute \(u_t(x \mid x_1)\). Let’s look at some examples.</p> <p><br></p> <h4 id="example-1-diffusion-conditional-vector-fields">Example 1: Diffusion Conditional Vector Fields</h4> <p>In the previous diffusion post, I looked into the variance exploding (VE), variance preserving (VP) and sub-VP SDEs, mapping from data to noise distributions.</p> <ol> <li>VE conditional path</li> </ol> <p>For VE, we kept adding noise until the signal got destroyed:</p> \[p_t(x|x_1) = \mathcal{N}(x|x_1, \sigma_{1-t}^2I)\] <p>The conditional vector field is then</p> \[u_t(x|x_1) = -\frac{\sigma'_{1-t}}{\sigma_{1-t}}(x-x_1)\] <ol> <li>VP conditional path</li> </ol> <p>For VP, while addiing noise, we also attenuate the signal:</p> \[p_t(x|x_1) = \mathcal{N}(x|\alpha_{1-t}x_1, (1 - \alpha_{1-t}^2)I)\] <p>The conditional vector field is then:</p> \[u_t(x|x_1) = \frac{\alpha_{1-t}'}{1 - \alpha_{1-t}^2}(\alpha_{1-t}x - x_1)\] <p>Note that this \(\alpha_t\) is decreasing with time \(t\) and parametrized by \(\beta(s)\):</p> \[\alpha_t = e^{-\frac{1}{2}\int_0^t\beta(s)ds}\] <p><br></p> <h4 id="example-2-optimal-transport-conditional-vector-fields">Example 2: Optimal Transport Conditional Vector Fields</h4> <p>One natural choice for this conditional probability path is to to define mean and std to be linear in time:</p> \[\mu_t(x|x_1) = tx_1\] \[\sigma_t(x|x_1) = 1 - (1 - \sigma_{min})t\] <p>The the conditional vector field is then:</p> \[u_t(x|x_1) = \frac{x_1 - (1 - \sigma_{min})x}{1 - (1 - \sigma_{min})t}\] <p><br></p> <p>So far, the conditional probability path and conditional vector field are conditioned on the data \(x_1\) , which is similar to the setup of diffusion modeling. However, the conditioning variable can be general, \(z = (x_1)\) or \(z = (x_1, x_0)\) by coupling the samples of prior and data distribution:</p> \[q(z) = q(x_0, x_1)\] <p><br></p> <h4 id="example-3-independent-cfm">Example 3: Independent CFM</h4> <p>For independent coupling, \(x_0\) and \(x_1\) are independent:</p> \[q(z) = q(x_0)q(x_1) = p_0(x_0)p_1(x_1)\] <p>We can use a simple choice of conditional probability path:</p> \[p_t(x|z) = p_t(x|x_0, x_1) = \mathcal{N}(x| tx_1+(1-t)x_0, \sigma^2)\] <p>For this case</p> \[\begin{align*} \mu_t(z) = \mu_t(x_0, x_1) = tx_1 + (1-t)x_0 \\ \sigma_t(z) = \sigma_t(x_0, x_1) = \sigma^2 \end{align*}\] <p>Then the conditional vector field is then:</p> \[u_t(x|z) = u_t(x|x_0, x_1) = x_1 - x_0\] <p>which is the simplest form of flow matching and is quite neat.</p> <p>The following is the sample code snippet that shapes a Gaussian noisy distribution \(p_0\) into a data distribution \(p_1\), which is a moon distribution.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">## Imports
</span><span class="kn">import</span> <span class="n">torch</span> 
<span class="kn">from</span> <span class="n">torch</span> <span class="kn">import</span> <span class="n">nn</span><span class="p">,</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="n">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_moons</span>

<span class="c1">## Flow class
</span><span class="k">class</span> <span class="nc">Flow</span><span class="p">(</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">64</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">().</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">net</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ELU</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ELU</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">nn</span><span class="p">.</span><span class="nc">ELU</span><span class="p">(),</span>
            <span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
 
    <span class="c1"># This is v_{t, \theta}(x) that regress the vector field u_t
</span>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">x_t</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">net</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">x_t</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="c1"># This is for midpoint sampling and we will take a look later
</span>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x_t</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">t_start</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">t_end</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="n">t_start</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">).</span><span class="nf">expand</span><span class="p">(</span><span class="n">x_t</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">x_t</span> <span class="o">+</span> <span class="p">(</span><span class="n">t_end</span> <span class="o">-</span> <span class="n">t_start</span><span class="p">)</span> <span class="o">*</span> <span class="nf">self</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t_start</span> <span class="o">+</span> <span class="p">(</span><span class="n">t_end</span> <span class="o">-</span> <span class="n">t_start</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">x_t</span><span class="o">=</span> <span class="n">x_t</span> <span class="o">+</span> <span class="nf">self</span><span class="p">(</span><span class="n">x_t</span><span class="o">=</span><span class="n">x_t</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t_start</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">t_end</span> <span class="o">-</span> <span class="n">t_start</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        
<span class="c1">## Training
</span><span class="n">flow</span> <span class="o">=</span> <span class="nc">Flow</span><span class="p">()</span>

<span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">optim</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">flow</span><span class="p">.</span><span class="nf">parameters</span><span class="p">(),</span> <span class="mf">1e-2</span><span class="p">)</span>
<span class="n">loss_fn</span> <span class="o">=</span> <span class="n">nn</span><span class="p">.</span><span class="nc">MSELoss</span><span class="p">()</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
		
		<span class="c1"># Sample t \in [0, 1]
</span>		<span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">x_1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># sample x_1 ~ q
</span>    <span class="n">x_1</span> <span class="o">=</span> <span class="nc">Tensor</span><span class="p">(</span><span class="nf">make_moons</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="c1"># sample x_0 ~ p
</span>    <span class="n">x_0</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn_like</span><span class="p">(</span><span class="n">x_1</span><span class="p">)</span>
    
    <span class="c1"># compute x_t given sigma_t = 0
</span>    <span class="n">x_t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">x_0</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">x_1</span>
    
    <span class="c1"># compute vector field u_t
</span>    <span class="n">dx_t</span> <span class="o">=</span> <span class="n">x_1</span> <span class="o">-</span> <span class="n">x_0</span>
    
    <span class="c1"># regress on the vector field
</span>    <span class="n">optimizer</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>
    <span class="nf">loss_fn</span><span class="p">(</span><span class="nf">flow</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">x_t</span><span class="o">=</span><span class="n">x_t</span><span class="p">),</span> <span class="n">dx_t</span><span class="p">).</span><span class="nf">backward</span><span class="p">()</span>
    <span class="n">optimizer</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>
</code></pre></div></div> <p><br> What about sampling?</p> <p>Once we get or approximate the ground truth vector field \(u_t(x_t \mid z)\) we can used it to transform a sampled point anywhere and if we do this iteratively (integrate) from \(t=0\) to \(t=1\), we can recover the data. This can be done using any ODE solver like RK or Euler methods etc.</p> <p>In the <code class="language-plaintext highlighter-rouge">Flow.step</code> function of above code, we used the midpoint method. Say we have an odinary differential equation:</p> \[y'(t) = f(t, y(t)); y(t_0) = y_0\] <p>We can use the first order approximation to find \(y(t_0+\Delta t)\):</p> \[y(t_0+\Delta t) = y(t_0) + \Delta ty'(t_0)\] <p>This can be better approximated using the derivative at the midpoint, namely \(y’(t_0 + \frac{\Delta t}{2})\):</p> \[y(t_0 + \Delta t) = y(t_0) + \Delta ty'(t_0 + \frac{\Delta t}{2}) = y(t_0) + \Delta tf(t_0 + \frac{\Delta t}{2}, y(t_0+\frac{\Delta t}{2}))\] <p>And the midpoint can be computed</p> \[y(t_0 + \frac{\Delta t}{2}) = \frac{1}{2}(y(t_0) + y(t_0 + \Delta t))\] <p>But we’re now trying to find \(y(t_0+\Delta t)\). So we need to approximate the midpoint using first order:</p> \[y(t_0 + \frac{\Delta t}{2}) = y(t_0) + \frac{\Delta t}{2}y'(t_0) = y(t_0) + \frac{\Delta t}{2}f(t_0, y(t_0))\] <p>Finally, we have</p> \[y(t_0 + \Delta t) = y(t_0) + \Delta tf(t_0 + \frac{\Delta t}{2}, y(t_0) + \frac{\Delta t}{2}f(t_0, y(t_0)))\] <p>So for our samples at \(t\), \(x_t\) given \(u_t(x_t)\)</p> \[x_{t+dt} = x_t + u_{t+dt/2}\left(x_t + \frac{dt}{2}u_t(x_t)\right)\] <p>For sampling:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">n_steps</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">time_steps</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_steps</span><span class="p">):</span>
		<span class="c1"># the distribution path gor pushed forward &lt;-&gt; The data x got transformed by flow
</span>    <span class="n">x</span> <span class="o">=</span> <span class="n">flow</span><span class="p">.</span><span class="nf">step</span><span class="p">(</span><span class="n">x_t</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">t_start</span><span class="o">=</span><span class="n">time_steps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t_end</span><span class="o">=</span><span class="n">time_steps</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
</code></pre></div></div> <p><br></p> <h4 id="example-4-minibatch-optimal-transport-cfm">Example 4: Minibatch Optimal Transport CFM</h4> <p>Typically these flow matching (or diffusion) models are trained using minibatch:</p> <ol> <li>Sample time \(t\in [0, 1]\)</li> <li>Sample data \(x_1 \sim p_1 \sim q\) and \(x_0\sim p_0\)</li> <li>Compute the noised data \(x_t\) in terms of \(x_0\) and \(x_1\)</li> <li>Use the model \(f_{t,\theta}(x_t)\) to regress on the flow vector fields, noises or scores, etc.</li> </ol> <p>The issue for the flow matching model is that these flow vector fields might cross if we sample randomly from \(p_0\) and \(p_1\). This means that at a given noised data \(x_t\) there might exist <strong>NON-UNIQUE</strong> flow vector field \(u_t(x_t \mid x_0,x_1)\), making the training difficult because the neural net model is one-to-one. It can be mitigated by re-shuffling the minibatch samples via optimal transport.</p> <p>So at train time we do the following:</p> <ol> <li>Sample \(t\in[0,1]\)</li> <li>Sample data point \(x_1\sim q(x) = p_1(x)\)</li> <li>Sample data point \(x_0 \sim p_0(x)\)</li> <li><strong>Reshuffle / rearrange minibatch via optimal transport</strong></li> <li>Sample \(x_t \sim p_t(x \mid x_0, x_1)\)</li> <li>Compute corresponding vector field \(u_t(x_t \mid x_0, x_1)\)</li> <li>Use neural network \(v_{t,\theta}(x_t)\) to regress on the vector field \(u_t(x_t \mid x_0, x_1)\)</li> </ol> <p><br></p> <h4 id="example-5-schrodinger-bridge">Example 5: Schrodinger Bridge</h4> <p>The Schrodinger Bridge is trying to vary the conditional variance in the conditional probability path, \(\sigma_t(z) = \sigma_t(x_0, x_1)\) such that \(p_0\) and \(p_1\) respect the prior/data distributions more faithfully.</p> \[\begin{align*} \mu_t(x_0, x_1) = tx_1 + (1-t)x_0 \\ \sigma_t(x_0, x_1) = \sqrt{t(1-t)}\sigma \end{align*}\] <p>Then the conditional vector field is then:</p> \[u_t(x|z) = u_t(x|x_0, x_1) = \frac{1-2t}{2t(1-t)}\left[ x-(tx_1 + (1-t)x_0) \right] + (x_1 - x_0)\] <p>It is also possible to train flow and score models at the same time, which is the <code class="language-plaintext highlighter-rouge">SF2M</code> model, generating stochastic trajectories in the sampling.</p> <p><br></p> <p>Likelihood calculation?</p> <p>One benefit of using flow generative model is that they allow the tractable computation of the <strong>EXACT</strong> likelihood \(\log{p_1(x)}\) for all \(x\). Start from the flow ODE:</p> \[\frac{d}{dt}\psi_t(x) = u_t(\psi_t(x)); \psi_0(x) = x\] <p>We can use the <code class="language-plaintext highlighter-rouge">instantaneous change of variable theorem</code>:</p> <p>Let \(\mathbf{z}(t)\) be finite continuous random variable with probability \(p(\mathbf{z}(t))\) dependent on time. Let</p> \[\frac{d\mathbf{z}}{dt} = f(\mathbf{z}(t), t)\] <p>be an ODE that describe a time-dependent transformation. Then the the log likelihood of \(\mathbf{z}\) follows the ODE:</p> \[\frac{\partial \log{p(\mathbf{z}(t))}}{\partial t} = -\text{tr}\left[\frac{d\mathbf{f}}{d\mathbf{z(t)}} \right] = -(\nabla\cdot\mathbf{f})(\mathbf{z}(t))\] <p>Here \(\mathbf{z} \in \mathbf{R}^d\), \(p: \mathbf{R}^d \to \mathbf{R}\), \(\mathbf{f}: \mathbf{R}^d \times t \to \mathbf{R}^d\).</p> \[\mathbf{f}(z_1, z_2, ..., z_d, t) = (f_1, f_2, ..., f_d)\] \[\frac{d\mathbf{f}}{d\mathbf{z}} = \begin{bmatrix} \frac{\partial f_1}{\partial z_1} &amp; \frac{\partial f_1}{\partial z_2} &amp; \frac{\partial f_1}{\partial z_3} &amp; \dots &amp; \frac{\partial f_1}{\partial z_d} \\ \frac{\partial f_2}{\partial z_1} &amp; \frac{\partial f_2}{\partial z_2} &amp; \frac{\partial f_2}{\partial z_3} &amp; \dots &amp; \frac{\partial f_2}{\partial z_d} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ \frac{\partial f_d}{\partial z_1} &amp; \frac{\partial f_3}{\partial z_2} &amp; \frac{\partial f_d}{\partial z_3} &amp; \dots &amp; \frac{\partial f_d}{\partial z_d} \end{bmatrix}\] <p>Now \(\mathbf{f} \to u_t\) and \(\mathbf{z} \to \psi_t(x)\) we have</p> \[\frac{\partial \log p_t(\psi_t(x))}{\partial t} = -\text{tr}\left[\frac{\partial u_t}{\partial x}(\psi_t(x)) \right] = -(\nabla\cdot u_t)(\psi_t(x))\] <p>The divergence can be computed using the Hutchinson’s trace estimator</p> \[\text{tr}(M) = \mathbf{E}_Z\text{tr}[Z^TMZ]\] <p>where \(\mathbf{E}[Z]=0\) and \(\text{Cov}(Z, Z) = I\) for a fixed sample of \(Z\).</p> <p>Let’s call \(\psi_t(x) = f(t)\) and \(\log{p_t(\psi_t(x))} = g(t)\) and we have access to \(u_t\). Computing an unbiased estimate of \(\log{p_1(x)}\) involves simulating the following set of ODEs back in time:</p> \[\begin{align} \frac{df}{dt} = u_t(f(t)) \\ \frac{dg}{dt} = -\text{tr}\left[Z^T\frac{\partial u_t}{\partial x}(f(t)) Z \right] \end{align}\] <p>with \(f(1) = x\) and \(g(1) = 0\)</p> \[\log{p_1(x)} = \log{p_0(f(0))} - g(0)\] <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">compute_likelihood</span><span class="p">(</span>
        <span class="n">self</span><span class="p">,</span>
        <span class="n">x_1</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">log_p0</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">Tensor</span><span class="p">],</span>
        <span class="n">step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="sh">"</span><span class="s">euler</span><span class="sh">"</span><span class="p">,</span>
        <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
        <span class="n">rtol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
        <span class="n">time_grid</span><span class="p">:</span> <span class="n">Tensor</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]),</span>
        <span class="n">return_intermediates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
        <span class="n">exact_divergence</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
        <span class="n">enable_grad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">model_extras</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Tensor</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">Tensor</span><span class="p">]]:</span>
        <span class="sa">r</span><span class="sh">"""</span><span class="s">Solve for log likelihood given a target sample at :math:`t=0`.

        Works similarly to sample, but solves the ODE in reverse to compute the log-likelihood. The velocity model must be differentiable with respect to x.
        The function assumes log_p0 is the log probability of the source distribution at :math:`t=0`.

        Args:
            x_1 (Tensor): target sample (e.g., samples :math:`X_1 \sim p_1`).
            log_p0 (Callable[[Tensor], Tensor]): Log probability function of the source distribution.
            step_size (Optional[float]): The step size. Must be None for adaptive step solvers.
            method (str): A method supported by torchdiffeq. Defaults to </span><span class="sh">"</span><span class="s">euler</span><span class="sh">"</span><span class="s">. Other commonly used solvers are </span><span class="sh">"</span><span class="s">dopri5</span><span class="sh">"</span><span class="s">, </span><span class="sh">"</span><span class="s">midpoint</span><span class="sh">"</span><span class="s"> and </span><span class="sh">"</span><span class="s">heun3</span><span class="sh">"</span><span class="s">. For a complete list, see torchdiffeq.
            atol (float): Absolute tolerance, used for adaptive step solvers.
            rtol (float): Relative tolerance, used for adaptive step solvers.
            time_grid (Tensor): If step_size is None then time discretization is set by the time grid. Must start at 1.0 and end at 0.0, otherwise the likelihood computation is not valid. Defaults to torch.tensor([1.0, 0.0]).
            return_intermediates (bool, optional): If True then return intermediate time steps according to time_grid. Otherwise only return the final sample. Defaults to False.
            exact_divergence (bool): Whether to compute the exact divergence or use the Hutchinson estimator.
            enable_grad (bool, optional): Whether to compute gradients during sampling. Defaults to False.
            **model_extras: Additional input for the model.

        Returns:
            Union[Tuple[Tensor, Tensor], Tuple[Sequence[Tensor], Tensor]]: Samples at time_grid and log likelihood values of given x_1.
        </span><span class="sh">"""</span>
        <span class="nf">assert </span><span class="p">(</span>
            <span class="n">time_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.0</span> <span class="ow">and</span> <span class="n">time_grid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span>
        <span class="p">),</span> <span class="sa">f</span><span class="sh">"</span><span class="s">Time grid must start at 1.0 and end at 0.0. Got </span><span class="si">{</span><span class="n">time_grid</span><span class="si">}</span><span class="sh">"</span>

        <span class="c1"># Fix the random projection for the Hutchinson divergence estimator
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">exact_divergence</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">randn_like</span><span class="p">(</span><span class="n">x_1</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">x_1</span><span class="p">.</span><span class="n">device</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.0</span>

        <span class="k">def</span> <span class="nf">ode_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">velocity_model</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="o">**</span><span class="n">model_extras</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">dynamics_func</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span>
            <span class="n">xt</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="nf">set_grad_enabled</span><span class="p">(</span><span class="bp">True</span><span class="p">):</span>
                <span class="n">xt</span><span class="p">.</span><span class="nf">requires_grad_</span><span class="p">()</span>
                <span class="n">ut</span> <span class="o">=</span> <span class="nf">ode_func</span><span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">exact_divergence</span><span class="p">:</span>
                    <span class="c1"># Compute exact divergence
</span>                    <span class="n">div</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">ut</span><span class="p">.</span><span class="nf">flatten</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">div</span> <span class="o">+=</span> <span class="nf">gradient</span><span class="p">(</span><span class="n">ut</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">xt</span><span class="p">,</span> <span class="n">create_graph</span><span class="o">=</span><span class="bp">True</span><span class="p">)[:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Compute Hutchinson divergence estimator E[z^T D_x(ut) z]
</span>                    <span class="n">ut_dot_z</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">einsum</span><span class="p">(</span>
                        <span class="sh">"</span><span class="s">ij,ij-&gt;i</span><span class="sh">"</span><span class="p">,</span> <span class="n">ut</span><span class="p">.</span><span class="nf">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">z</span><span class="p">.</span><span class="nf">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">grad_ut_dot_z</span> <span class="o">=</span> <span class="nf">gradient</span><span class="p">(</span><span class="n">ut_dot_z</span><span class="p">,</span> <span class="n">xt</span><span class="p">)</span>
                    <span class="n">div</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">einsum</span><span class="p">(</span>
                        <span class="sh">"</span><span class="s">ij,ij-&gt;i</span><span class="sh">"</span><span class="p">,</span>
                        <span class="n">grad_ut_dot_z</span><span class="p">.</span><span class="nf">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                        <span class="n">z</span><span class="p">.</span><span class="nf">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                    <span class="p">)</span>

            <span class="k">return</span> <span class="n">ut</span><span class="p">.</span><span class="nf">detach</span><span class="p">(),</span> <span class="n">div</span><span class="p">.</span><span class="nf">detach</span><span class="p">()</span>

        <span class="n">y_init</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">x_1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">x_1</span><span class="p">.</span><span class="n">device</span><span class="p">))</span>
        <span class="n">ode_opts</span> <span class="o">=</span> <span class="p">{</span><span class="sh">"</span><span class="s">step_size</span><span class="sh">"</span><span class="p">:</span> <span class="n">step_size</span><span class="p">}</span> <span class="k">if</span> <span class="n">step_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="p">{}</span>

        <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="nf">set_grad_enabled</span><span class="p">(</span><span class="n">enable_grad</span><span class="p">):</span>
            <span class="n">sol</span><span class="p">,</span> <span class="n">log_det</span> <span class="o">=</span> <span class="nf">odeint</span><span class="p">(</span>
                <span class="n">dynamics_func</span><span class="p">,</span>
                <span class="n">y_init</span><span class="p">,</span>
                <span class="n">time_grid</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                <span class="n">options</span><span class="o">=</span><span class="n">ode_opts</span><span class="p">,</span>
                <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span>
                <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">x_source</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">source_log_p</span> <span class="o">=</span> <span class="nf">log_p0</span><span class="p">(</span><span class="n">x_source</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_intermediates</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sol</span><span class="p">,</span> <span class="n">source_log_p</span> <span class="o">+</span> <span class="n">log_det</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">source_log_p</span> <span class="o">+</span> <span class="n">log_det</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div> <p><br></p> <h3 id="implementation-of-2d-case">Implementation of 2D Case</h3> <p>Here, we are going to implement the <code class="language-plaintext highlighter-rouge">I-CFM</code>, <code class="language-plaintext highlighter-rouge">OT-CFM</code>, <code class="language-plaintext highlighter-rouge">Schrodinger Bridge CFM</code> and <code class="language-plaintext highlighter-rouge">SF2M</code> for the following generative examples:</p> <ol> <li>Generating moon from 8 Gaussians</li> <li>Generating moon from noises</li> <li>Generating checkerboard from noises</li> <li>Generating 8 gaussains from noises And compute the corresponding likelihoods.</li> </ol> <p>Some library imports:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span><span class="p">,</span> <span class="n">math</span><span class="p">,</span> <span class="n">torch</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">copy</span>

<span class="kn">import</span> <span class="n">ot</span> <span class="k">as</span> <span class="n">pot</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="k">assert</span> <span class="n">torch</span><span class="p">.</span><span class="n">cuda</span><span class="p">.</span><span class="nf">is_available</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="n">cuda</span><span class="p">.</span><span class="nf">device_count</span><span class="p">())</span>
<span class="n">DEVICE</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">device</span><span class="p">(</span><span class="sh">'</span><span class="s">cuda</span><span class="sh">'</span><span class="p">)</span>

<span class="kn">from</span> <span class="n">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="n">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="c1"># torchdyn libraries
</span><span class="kn">from</span> <span class="n">torchdyn.core</span> <span class="kn">import</span> <span class="n">NeuralODE</span>
<span class="kn">from</span> <span class="n">torchdyn.datasets</span> <span class="kn">import</span> <span class="n">generate_moons</span>

<span class="c1"># for likelihood computation
</span><span class="kn">import</span> <span class="n">torchdiffeq</span>
<span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="n">torch</span> <span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="n">torch.distributions</span> <span class="kn">import</span> <span class="n">Independent</span><span class="p">,</span> <span class="n">Normal</span>

</code></pre></div></div> <p>Some utils functions and distributions</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Important utils functions
</span>
<span class="k">def</span> <span class="nf">sample_conditional_pt</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span> 
    <span class="sh">'''</span><span class="s">
    Draw a sample from N(mu_t(x0, x1), sigma), where
    mu_t(x0, x1) = t * x1 + (1 - t) * x0 being the interpolation between x0 and x1
    </span><span class="sh">'''</span>
    
    <span class="k">assert</span> <span class="n">x0</span><span class="p">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">x1</span><span class="p">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">t</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x0</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">]</span>
    <span class="n">mu_t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">x0</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn_like</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mu_t</span> <span class="o">+</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">epsilon</span>


<span class="c1"># conditional vector field
</span><span class="k">def</span> <span class="nf">conditional_vector_field</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">xt</span><span class="p">):</span> 
    <span class="sh">'''</span><span class="s">
    Compute the conditional vector fields u_t(x| x0, x1) = sigma_t</span><span class="sh">'</span><span class="s"> (x - mu_t) / sigma_t + mu_t</span><span class="sh">'</span><span class="s">
    Since sigma_t = sigma is a constant, sigma_t</span><span class="sh">'</span><span class="s"> = 0 in the above scenerio
    u_t(x| x0, x1) = mu_t</span><span class="sh">'</span><span class="s"> = x1 - x0
    </span><span class="sh">'''</span>
    <span class="k">return</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span>


<span class="c1"># functions for the data utils
</span>
<span class="c1"># sample 8 gaussians
</span><span class="k">def</span> <span class="nf">eight_normal_sample</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">distributions</span><span class="p">.</span><span class="n">multivariate_normal</span><span class="p">.</span><span class="nc">MultivariateNormal</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">dim</span><span class="p">),</span> <span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">eye</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
               <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
               <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
               <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
               <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span>
               <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span>
               <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span>
               <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">))]</span>
                        
    <span class="n">centers</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span> <span class="o">*</span> <span class="n">scale</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="nf">sample</span><span class="p">((</span><span class="n">n</span><span class="p">,))</span>
    <span class="n">multi</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">multinomial</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">n</span><span class="p">,</span> <span class="n">replacement</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="n">data</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">centers</span><span class="p">[</span><span class="n">multi</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">noise</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">stack</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">sample_8_gaussians</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span> 
    <span class="k">return</span> <span class="nf">eight_normal_sample</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="mf">0.1</span><span class="p">).</span><span class="nf">float</span><span class="p">()</span>

<span class="c1"># sample moons
</span><span class="k">def</span> <span class="nf">sample_moons</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span> 
    <span class="n">x0</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">generate_moons</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x0</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span>

<span class="c1"># sample Gaussians
</span><span class="k">def</span> <span class="nf">sample_noise</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span> 
    <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">sample_checkerboard_data</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">n_squares</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="c1"># Create a grid
</span>    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_squares</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_squares</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Create the checkerboard pattern
</span>    <span class="n">pattern</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">n_squares</span><span class="p">,</span> <span class="n">n_squares</span><span class="p">))</span>
    <span class="n">pattern</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">pattern</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Generate points
</span>    <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_squares</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_squares</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">n_points</span> <span class="o">//</span> <span class="p">(</span><span class="n">n_squares</span> <span class="o">*</span> <span class="n">n_squares</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="n">xx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">n_squares</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="n">yy</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">],</span> <span class="n">yy</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">n_squares</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
                <span class="n">points</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span>

    <span class="c1"># Convert to numpy array and add noise
</span>    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">+=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">points</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">from_numpy</span><span class="p">(</span><span class="n">points</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">points</span> <span class="o">*</span> <span class="n">scale</span>


<span class="c1"># plot the trajs
</span><span class="k">def</span> <span class="nf">plot_trajs</span><span class="p">(</span><span class="n">trajs</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">,</span> <span class="n">flow_line</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span> 
    
    <span class="n">n_traj</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">trajs</span><span class="p">)</span>
    
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_traj</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">traj</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">trajs</span><span class="p">):</span> 
        <span class="k">if</span> <span class="n">flow_line</span><span class="p">:</span> 
            <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">scatter</span><span class="p">(</span><span class="n">traj</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">traj</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="sh">'</span><span class="s">olive</span><span class="sh">'</span><span class="p">)</span>
        
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">scatter</span><span class="p">(</span><span class="n">traj</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">traj</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">scatter</span><span class="p">(</span><span class="n">traj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">traj</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="sh">'</span><span class="s">tab:red</span><span class="sh">'</span><span class="p">)</span>
        
        <span class="n">legend</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">Flow</span><span class="sh">'</span><span class="p">]</span> <span class="k">if</span> <span class="n">flow_line</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">legend</span> <span class="o">+=</span> <span class="p">[</span><span class="sh">'</span><span class="s">Prior sample ~ p0</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">Data sample ~ p1</span><span class="sh">'</span><span class="p">]</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">legend</span><span class="p">(</span><span class="n">legend</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_xticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_yticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">checkpoint at step </span><span class="si">{</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_steps</span> <span class="o">//</span> <span class="n">n_traj</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>

    <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
    
</code></pre></div></div> <p>Let’s take a look at what kind of data we are dealing with:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">batch_size</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">g8</span><span class="p">,</span> <span class="n">mn</span><span class="p">,</span> <span class="n">cb</span> <span class="o">=</span> <span class="nf">sample_8_gaussians</span><span class="p">(</span><span class="n">batch_size</span><span class="p">),</span> <span class="nf">sample_moons</span><span class="p">(</span><span class="n">batch_size</span><span class="p">),</span> <span class="nf">sample_checkerboard_data</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="n">g8</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">g8</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">Gaussians</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="n">mn</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">mn</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">tab:orange</span><span class="sh">'</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">Moons</span><span class="sh">'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="n">cb</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cb</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">tab:green</span><span class="sh">'</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">Checkerboard</span><span class="sh">'</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/distributions-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/distributions-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/distributions-1400.webp"></source> <img src="/assets/img/posts/cfm/distributions.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p>Ok, now to the model, which is just a shallow MLP, taking \((x, t)\) and outputting the conditional vector fields.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MLP</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span> 
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">out_dim</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">time_varying</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span> 
        <span class="nf">super</span><span class="p">(</span><span class="n">MLP</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">time_varying</span> <span class="o">=</span> <span class="n">time_varying</span>
        <span class="k">if</span> <span class="n">out_dim</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">out_dim</span> <span class="o">=</span> <span class="n">dim</span>
        
        <span class="n">self</span><span class="p">.</span><span class="n">net</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">Sequential</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">dim</span> <span class="o">+</span> <span class="nf">int</span><span class="p">(</span><span class="n">time_varying</span><span class="p">),</span> <span class="n">hidden_dim</span><span class="p">),</span> 
                                       <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">SELU</span><span class="p">(),</span> 
                                       <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">),</span> 
                                       <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">SELU</span><span class="p">(),</span> 
                                       <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="n">hidden_dim</span><span class="p">),</span> 
                                       <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">SELU</span><span class="p">(),</span>
                                       <span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="nc">Linear</span><span class="p">(</span><span class="n">hidden_dim</span><span class="p">,</span> <span class="n">out_dim</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">net</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    
<span class="k">class</span> <span class="nc">torch_wrapper</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">Wraps model to torchdyn compatible format.</span><span class="sh">'''</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">torch_wrapper</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">model</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="nf">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[...,</span> <span class="bp">None</span><span class="p">]],</span> <span class="mi">1</span><span class="p">))</span>
                                       
</code></pre></div></div> <p>The first 3 cases can be wrapped in a function, since they only differ in the design of \(p_t\) and \(u_t\).</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># sampling wrapper 
</span><span class="k">def</span> <span class="nf">sampling</span><span class="p">(</span><span class="n">prior_samples</span><span class="p">,</span> <span class="n">checkpoints</span><span class="p">):</span> 
    <span class="n">trajs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">checkpoint</span> <span class="ow">in</span> <span class="nf">tqdm</span><span class="p">(</span><span class="n">checkpoints</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="sh">'</span><span class="s">sampling from checkpoint</span><span class="sh">'</span><span class="p">):</span> 
        <span class="n">node</span> <span class="o">=</span> <span class="nc">NeuralODE</span><span class="p">(</span><span class="nf">torch_wrapper</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">),</span> <span class="n">solver</span><span class="o">=</span><span class="sh">"</span><span class="s">dopri5</span><span class="sh">"</span><span class="p">,</span> <span class="n">sensitivity</span><span class="o">=</span><span class="sh">"</span><span class="s">adjoint</span><span class="sh">"</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="nf">no_grad</span><span class="p">():</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nf">trajectory</span><span class="p">(</span><span class="n">prior_samples</span><span class="p">,</span> <span class="n">t_span</span><span class="o">=</span><span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span> <span class="c1"># integrating from 0 to 1 in 100 steps
</span>            <span class="n">trajs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">traj</span><span class="p">.</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">numpy</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">trajs</span>

<span class="c1"># cfm training wrapper:
</span><span class="k">def</span> <span class="nf">cfm_wrapper</span><span class="p">(</span><span class="n">p0_sampler</span><span class="p">,</span> <span class="n">p1_sampler</span><span class="p">,</span> <span class="n">pt_sampler</span><span class="p">,</span> <span class="n">vector_field</span><span class="p">,</span> <span class="n">ot_sampler</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">2048</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="n">likelihood</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span> 
    
    <span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">n_checkpoints</span> <span class="o">=</span> <span class="mi">5</span>
    
    <span class="n">model</span> <span class="o">=</span> <span class="nc">MLP</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">time_varying</span><span class="o">=</span><span class="bp">True</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>
    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">optim</span><span class="p">.</span><span class="nc">AdamW</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">())</span>

    <span class="n">checkpoints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pbar</span> <span class="o">=</span> <span class="nf">tqdm</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">n_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pbar</span><span class="p">:</span> 
        
        <span class="c1"># sample x0 ~ p0 and x1 ~ p1
</span>        <span class="n">x0</span> <span class="o">=</span> <span class="nf">p0_sampler</span><span class="p">(</span><span class="n">batch_size</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="nf">p1_sampler</span><span class="p">(</span><span class="n">batch_size</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>
        
        <span class="c1"># minibatch Optimal Transport
</span>        <span class="c1"># match rows using OT plan
</span>        <span class="k">if</span> <span class="n">ot_sampler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">ot_sampler</span><span class="p">.</span><span class="nf">sample_plan</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>

        <span class="c1"># sample time
</span>        <span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">x0</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x0</span><span class="p">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">DEVICE</span><span class="p">)</span>
        
        <span class="c1"># sample xt ~ pt conditional probability path
</span>        <span class="n">xt</span> <span class="o">=</span> <span class="nf">pt_sampler</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
        
        <span class="c1"># compute the conditional vector field
</span>        <span class="n">ut</span> <span class="o">=</span> <span class="nf">vector_field</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">xt</span><span class="p">)</span>
        
         <span class="c1"># the model input is the noisy point xt and time 
</span>        <span class="c1"># the model output is the flow to matching that of ut
</span>        <span class="n">vt</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">xt</span><span class="p">,</span> <span class="n">t</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># loss is the conditional flow matching loss, L_CFM
</span>        <span class="n">loss</span> <span class="o">=</span> <span class="p">((</span><span class="n">vt</span> <span class="o">-</span> <span class="n">ut</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">).</span><span class="nf">mean</span><span class="p">()</span>
        
        <span class="n">optimizer</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>
        <span class="n">loss</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">pbar</span><span class="p">.</span><span class="nf">set_description</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Training step </span><span class="si">{</span><span class="n">k</span><span class="si">:</span><span class="mi">06</span><span class="n">d</span><span class="si">}</span><span class="s">, loss = </span><span class="si">{</span><span class="n">loss</span><span class="p">.</span><span class="nf">item</span><span class="p">()</span><span class="si">:</span><span class="p">.</span><span class="mi">3</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">k</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_steps</span> <span class="o">//</span> <span class="n">n_checkpoints</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span> <span class="n">checkpoints</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">copy</span><span class="p">.</span><span class="nf">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>

    <span class="c1"># sampling 
</span>    <span class="c1"># Generating samples x0' ~ p0
</span>    <span class="n">prior_samples</span> <span class="o">=</span> <span class="nf">p0_sampler</span><span class="p">(</span><span class="n">batch_size</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>
    
    <span class="c1"># use the model to get estimate of ut and use it to transform the x0' iteratively (integrate) 
</span>    <span class="n">trajs</span> <span class="o">=</span> <span class="nf">sampling</span><span class="p">(</span><span class="n">prior_samples</span><span class="p">,</span> <span class="n">checkpoints</span><span class="p">)</span>
    
    <span class="c1"># plotting
</span>    <span class="nf">plot_trajs</span><span class="p">(</span><span class="n">trajs</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="n">n_steps</span><span class="p">,</span> <span class="n">flow_line</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    
    <span class="c1"># compute likelihood
</span>    <span class="k">if</span> <span class="n">likelihood</span><span class="p">:</span> 
        <span class="n">x_1</span><span class="p">,</span> <span class="n">lls</span> <span class="o">=</span> <span class="nf">compute_likelihood_checkpoints</span><span class="p">(</span><span class="n">checkpoints</span><span class="p">,</span> <span class="n">exact_divergence</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="nf">plot_likelihood</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">lls</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div> <p>Here we will define the <code class="language-plaintext highlighter-rouge">compute_likelihood_checkpoints</code> and <code class="language-plaintext highlighter-rouge">plot_likelihood</code> functions:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># compute the gradient for the divergence calculation
</span><span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="n">output</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">grad_outputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">create_graph</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Compute the gradient of the inner product of output and grad_outputs w.r.t :math:`x`.

    Args:
        output (Tensor): [N, D] Output of the function.
        x (Tensor): [N, d_1, d_2, ... ] input
        grad_outputs (Optional[Tensor]): [N, D] Gradient of outputs, if `None`,
            then will use a tensor of ones
        create_graph (bool): If True, graph of the derivative will be constructed, allowing
            to compute higher order derivative products. Defaults to False.
    Returns:
        Tensor: [N, d_1, d_2, ... ]. the gradient w.r.t x.
    </span><span class="sh">"""</span>

    <span class="k">if</span> <span class="n">grad_outputs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="n">grad_outputs</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones_like</span><span class="p">(</span><span class="n">output</span><span class="p">).</span><span class="nf">detach</span><span class="p">()</span>
    <span class="n">grad</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">autograd</span><span class="p">.</span><span class="nf">grad</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">grad_outputs</span><span class="o">=</span><span class="n">grad_outputs</span><span class="p">,</span> <span class="n">create_graph</span><span class="o">=</span><span class="n">create_graph</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">grad</span>


<span class="k">def</span> <span class="nf">compute_likelihood</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">log_p0</span><span class="p">,</span> <span class="n">exact_divergence</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">n_evals</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">solver_method</span><span class="o">=</span><span class="sh">'</span><span class="s">dopri5</span><span class="sh">'</span><span class="p">,</span> <span class="n">solver_opts</span><span class="o">=</span><span class="p">{}):</span> 
    
    <span class="k">assert</span> <span class="n">x_1</span><span class="p">.</span><span class="n">device</span> <span class="o">==</span> <span class="nf">next</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">()).</span><span class="n">device</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">x_1</span><span class="p">.</span><span class="n">device</span>
    
    <span class="c1"># fixed time range from 1.0 to 0.0
</span>    <span class="n">time_range</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">tensor</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    
    
    <span class="c1"># random projection vectors for the Hutchinson divergence, constant w.r.t x
</span>    <span class="c1"># we should use the same z at any given time point, faster doing so as well
</span>    <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">randn_like</span><span class="p">(</span><span class="n">x_1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">exact_divergence</span> <span class="k">else</span> <span class="bp">None</span>

    
    <span class="c1"># === ODE System ===
</span>    <span class="c1"># set up the ODE equations for the likelihood calculation
</span>    <span class="k">def</span> <span class="nf">ode_system</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span> 
        <span class="sh">'''</span><span class="s">
        states = (x_t, log p_t(x_t))
        </span><span class="sh">'''</span>

        <span class="n">x_t</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="nf">set_grad_enabled</span><span class="p">(</span><span class="bp">True</span><span class="p">):</span>
            <span class="n">x_t</span><span class="p">.</span><span class="nf">requires_grad_</span><span class="p">()</span>
            <span class="n">u_t</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_t</span><span class="p">)</span>

            <span class="c1"># compute the exact divergence one by one
</span>            <span class="k">if</span> <span class="n">exact_divergence</span><span class="p">:</span> 
                <span class="k">assert</span> <span class="n">z</span> <span class="ow">is</span> <span class="bp">None</span>
                <span class="n">div</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">u_t</span><span class="p">.</span><span class="nf">flatten</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> 
                    <span class="c1"># definition of divergence of a neural network 
</span>                    <span class="c1"># using autograd through NN and sum over du_i/dx_i
</span>                    <span class="n">div</span> <span class="o">+=</span> <span class="nf">gradient</span><span class="p">(</span><span class="n">u_t</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">x_t</span><span class="p">,</span> <span class="n">create_graph</span><span class="o">=</span><span class="bp">True</span><span class="p">)[:,</span> <span class="n">i</span><span class="p">]</span>

            <span class="c1"># compute the divergence estimator using Hutchinson's formula
</span>            <span class="k">else</span><span class="p">:</span> 
                <span class="k">assert</span> <span class="n">z</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
                
                <span class="c1"># ut * z
</span>                <span class="n">ut_dot_z</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">einsum</span><span class="p">(</span><span class="sh">'</span><span class="s">ij,ij-&gt;i</span><span class="sh">'</span><span class="p">,</span> <span class="n">u_t</span><span class="p">.</span><span class="nf">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">z</span><span class="p">.</span><span class="nf">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

                <span class="c1"># [d (ut)/ dx] * z = d (ut * z) / dx
</span>                <span class="n">grad_ut_dot_z</span> <span class="o">=</span> <span class="nf">gradient</span><span class="p">(</span><span class="n">ut_dot_z</span><span class="p">,</span> <span class="n">x_t</span><span class="p">)</span>

                <span class="c1"># z^T * [d (ut)/ dx] * z = z^T * d (ut * z) / dx
</span>                <span class="n">div</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">einsum</span><span class="p">(</span><span class="sh">'</span><span class="s">ij,ij-&gt;i</span><span class="sh">'</span><span class="p">,</span> <span class="n">grad_ut_dot_z</span><span class="p">.</span><span class="nf">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">z</span><span class="p">.</span><span class="nf">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># just keep the values not the computational graph
</span>        <span class="k">return</span> <span class="n">u_t</span><span class="p">.</span><span class="nf">detach</span><span class="p">(),</span> <span class="n">div</span><span class="p">.</span><span class="nf">detach</span><span class="p">()</span>
    <span class="c1"># === End of ODE System === 
</span>    
    <span class="c1"># init state
</span>    <span class="n">state_init</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="n">x_1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">))</span>
    
    <span class="c1"># doing the integration back in time from 1.0 to 0.0
</span>    <span class="n">likelihoods</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_evals</span><span class="p">):</span> 
        <span class="c1"># do reverse in time
</span>        <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="nf">set_grad_enabled</span><span class="p">(</span><span class="bp">False</span><span class="p">):</span> 
            <span class="n">sol</span><span class="p">,</span> <span class="n">log_det</span> <span class="o">=</span> <span class="n">torchdiffeq</span><span class="p">.</span><span class="nf">odeint</span><span class="p">(</span><span class="n">ode_system</span><span class="p">,</span> <span class="n">state_init</span><span class="p">,</span> <span class="n">time_range</span><span class="p">,</span> 
                                              <span class="n">method</span><span class="o">=</span><span class="n">solver_method</span><span class="p">,</span> 
                                              <span class="n">options</span><span class="o">=</span><span class="n">solver_opts</span><span class="p">,</span>
                                              <span class="n">atol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> 
                                              <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
        <span class="c1"># x_0 and g_0
</span>        <span class="n">x_0</span><span class="p">,</span> <span class="n">g_0</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">log_det</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">log_p0_x0</span> <span class="o">=</span> <span class="nf">log_p0</span><span class="p">(</span><span class="n">x_0</span><span class="p">)</span>
        <span class="n">log_p1_x1</span> <span class="o">=</span> <span class="n">log_p0_x0</span> <span class="o">+</span> <span class="n">g_0</span>
        <span class="n">likelihood</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">log_p1_x1</span><span class="p">).</span><span class="nf">detach</span><span class="p">().</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">numpy</span><span class="p">()</span>
        <span class="n">likelihoods</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">likelihood</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">stack</span><span class="p">(</span><span class="n">likelihoods</span><span class="p">).</span><span class="nf">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="c1"># compute likelihood for all checkpoints: 
</span><span class="k">def</span> <span class="nf">compute_likelihood_checkpoints</span><span class="p">(</span><span class="n">checkpoints</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">grid_size</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">exact_divergence</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">n_evals</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">solver_method</span><span class="o">=</span><span class="sh">'</span><span class="s">dopri5</span><span class="sh">'</span><span class="p">,</span> <span class="n">solver_opts</span><span class="o">=</span><span class="p">{}):</span> 
    
    <span class="c1"># compute likelihood for the grid x_1
</span>    <span class="n">x_1</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">meshgrid</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">xy</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">),</span> <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">xy</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">))</span>
    <span class="n">x_1</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">stack</span><span class="p">([</span><span class="n">x_1</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">flatten</span><span class="p">(),</span> <span class="n">x_1</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">flatten</span><span class="p">()],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>
    
    <span class="c1"># log_p0
</span>    <span class="n">log_p0</span> <span class="o">=</span> <span class="nc">Independent</span><span class="p">(</span><span class="nc">Normal</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">DEVICE</span><span class="p">),</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">DEVICE</span><span class="p">)),</span> <span class="mi">1</span><span class="p">).</span><span class="n">log_prob</span>
    
    <span class="c1"># likelihoods
</span>    <span class="n">likelihoods</span> <span class="o">=</span> <span class="p">[</span><span class="nf">compute_likelihood</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="nf">torch_wrapper</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">),</span> <span class="n">log_p0</span><span class="p">,</span> <span class="n">exact_divergence</span><span class="o">=</span><span class="n">exact_divergence</span><span class="p">,</span> <span class="n">n_evals</span><span class="o">=</span><span class="n">n_evals</span><span class="p">,</span> <span class="n">solver_method</span><span class="o">=</span><span class="n">solver_method</span><span class="p">,</span> <span class="n">solver_opts</span><span class="o">=</span><span class="n">solver_opts</span><span class="p">)</span> <span class="k">for</span> <span class="n">checkpoint</span> <span class="ow">in</span> <span class="nf">tqdm</span><span class="p">(</span><span class="n">checkpoints</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="sh">'</span><span class="s">Computing Likelihood</span><span class="sh">'</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">x_1</span><span class="p">.</span><span class="nf">detach</span><span class="p">().</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">numpy</span><span class="p">(),</span> <span class="n">likelihoods</span>
    
<span class="c1"># plot the likelihoods
</span><span class="k">def</span> <span class="nf">plot_likelihood</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">likelihoods</span><span class="p">,</span> <span class="n">n_steps</span><span class="p">):</span> 
    
    <span class="n">n_likelihoods</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">likelihoods</span><span class="p">)</span>
    
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_likelihoods</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ll</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">likelihoods</span><span class="p">):</span> 
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">ll</span><span class="p">.</span><span class="nf">max</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.8</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">scatter</span><span class="p">(</span><span class="n">x_1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">ll</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="sh">'</span><span class="s">coolwarm</span><span class="sh">'</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
    
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_xticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_yticks</span><span class="p">([])</span>
        <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">checkpoint at step </span><span class="si">{</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n_steps</span> <span class="o">//</span> <span class="n">n_likelihoods</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>

    <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div> <h4 id="1-i-cfm">1. I-CFM</h4> <p><br> 1-1. 8-Gaussian to Moon:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">cfm_wrapper</span><span class="p">(</span><span class="n">sample_8_gaussians</span><span class="p">,</span> <span class="n">sample_moons</span><span class="p">,</span> <span class="n">pt_sampler</span><span class="o">=</span><span class="n">sample_conditional_pt</span><span class="p">,</span> <span class="n">vector_field</span><span class="o">=</span><span class="n">conditional_vector_field</span><span class="p">,</span> <span class="n">ot_sampler</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<span class="c1"># loss ~ 7.572
</span></code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig1-1s-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig1-1s-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig1-1s-1400.webp"></source> <img src="/assets/img/posts/cfm/fig1-1s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <p>1-2. Generating Moon</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">cfm_wrapper</span><span class="p">(</span><span class="n">sample_noise</span><span class="p">,</span> <span class="n">sample_moons</span><span class="p">,</span> <span class="n">pt_sampler</span><span class="o">=</span><span class="n">sample_conditional_pt</span><span class="p">,</span> <span class="n">vector_field</span><span class="o">=</span><span class="n">conditional_vector_field</span><span class="p">,</span> <span class="n">ot_sampler</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">likelihood</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># loss ~ 2.839
</span></code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig1-2s-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig1-2s-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig1-2s-1400.webp"></source> <img src="/assets/img/posts/cfm/fig1-2s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig1-2l-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig1-2l-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig1-2l-1400.webp"></source> <img src="/assets/img/posts/cfm/fig1-2l.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <p>1-3. Generating Checkerboard</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">cfm_wrapper</span><span class="p">(</span><span class="n">sample_noise</span><span class="p">,</span> <span class="n">sample_checkerboard_data</span><span class="p">,</span> <span class="n">pt_sampler</span><span class="o">=</span><span class="n">sample_conditional_pt</span><span class="p">,</span> <span class="n">vector_field</span><span class="o">=</span><span class="n">conditional_vector_field</span><span class="p">,</span> <span class="n">ot_sampler</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">likelihood</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># loss ~ 2.113
</span></code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig1-3s-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig1-3s-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig1-3s-1400.webp"></source> <img src="/assets/img/posts/cfm/fig1-3s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig1-3l-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig1-3l-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig1-3l-1400.webp"></source> <img src="/assets/img/posts/cfm/fig1-3l.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <p>1-4. Generating 8-Gaussians</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">cfm_wrapper</span><span class="p">(</span><span class="n">sample_noise</span><span class="p">,</span> <span class="n">sample_8_gaussians</span><span class="p">,</span> <span class="n">pt_sampler</span><span class="o">=</span><span class="n">sample_conditional_pt</span><span class="p">,</span> <span class="n">vector_field</span><span class="o">=</span><span class="n">conditional_vector_field</span><span class="p">,</span> <span class="n">ot_sampler</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">likelihood</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># loss ~ 4.999
</span></code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig1-4s-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig1-4s-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig1-4s-1400.webp"></source> <img src="/assets/img/posts/cfm/fig1-4s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig1-4l-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig1-4l-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig1-4l-1400.webp"></source> <img src="/assets/img/posts/cfm/fig1-4l.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <h4 id="2-minibatch-ot-cfm">2. Minibatch OT-CFM</h4> <p>For Minibatch OT, we aim to straighten or tidy up the flow line so that they don’t cross for that specific minibatch to make the learning easily</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">OTPlanSampler</span><span class="p">:</span> 
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="sh">'</span><span class="s">exact</span><span class="sh">'</span><span class="p">,</span> <span class="n">normalize_cost</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span> 
        
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="sh">'</span><span class="s">exact</span><span class="sh">'</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">ot_fn</span> <span class="o">=</span> <span class="nf">partial</span><span class="p">(</span><span class="n">pot</span><span class="p">.</span><span class="n">emd</span><span class="p">,</span> <span class="n">numThreads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="sh">'</span><span class="s">sinkhorn</span><span class="sh">'</span><span class="p">:</span> <span class="n">self</span><span class="p">.</span><span class="n">ot_fn</span> <span class="o">=</span> <span class="nf">partial</span><span class="p">(</span><span class="n">pot</span><span class="p">.</span><span class="n">sinkhorn</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="nc">NotImplementedError</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">normalize_cost</span> <span class="o">=</span> <span class="n">normalize_cost</span>
        
    <span class="k">def</span> <span class="nf">get_map</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">):</span> 
        
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pot</span><span class="p">.</span><span class="nf">unif</span><span class="p">(</span><span class="n">x0</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">pot</span><span class="p">.</span><span class="nf">unif</span><span class="p">(</span><span class="n">x1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">x0</span><span class="p">.</span><span class="nf">dim</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span> <span class="n">x0</span> <span class="o">=</span> <span class="n">x0</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">x0</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x1</span><span class="p">.</span><span class="nf">dim</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">x1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">x1</span> <span class="o">=</span> <span class="n">x1</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="n">x1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cdist</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">normalize_cost</span><span class="p">:</span> <span class="n">M</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">M</span><span class="p">.</span><span class="nf">max</span><span class="p">()</span>  <span class="c1"># should not be normalized when using minibatches
</span>        
        <span class="n">p</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">ot_fn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">.</span><span class="nf">detach</span><span class="p">().</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">numpy</span><span class="p">())</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="p">.</span><span class="nf">all</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">isfinite</span><span class="p">(</span><span class="n">p</span><span class="p">)):</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">ERROR: p is not finite</span><span class="sh">"</span><span class="p">)</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Cost mean, max</span><span class="sh">"</span><span class="p">,</span> <span class="n">M</span><span class="p">.</span><span class="nf">mean</span><span class="p">(),</span> <span class="n">M</span><span class="p">.</span><span class="nf">max</span><span class="p">())</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="nf">abs</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="nf">sum</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">:</span> <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">ones_like</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span>
        <span class="k">return</span> <span class="n">p</span>
    
    <span class="k">def</span> <span class="nf">sample_map</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span> 
        <span class="n">p</span> <span class="o">=</span> <span class="n">pi</span><span class="p">.</span><span class="nf">flatten</span><span class="p">()</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="n">p</span><span class="p">.</span><span class="nf">sum</span><span class="p">()</span>
        <span class="n">choices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="n">pi</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pi</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">divmod</span><span class="p">(</span><span class="n">choices</span><span class="p">,</span> <span class="n">pi</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">sample_plan</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span> 
        <span class="n">pi</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_map</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">sample_map</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">x0</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x0</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</code></pre></div></div> <p>Let’s see what OT did for the data:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># generate samples from p0 and p1
</span><span class="n">tmp0</span><span class="p">,</span> <span class="n">tmp1</span> <span class="o">=</span> <span class="nf">sample_8_gaussians</span><span class="p">(</span><span class="n">batch_size</span><span class="p">),</span> <span class="nf">sample_moons</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>

<span class="c1"># the data p0 and p1 is generated randomly, so in minibatch, we try to match first row of p0 to first row of p1
# this results in crossing of the flow paths or the vector fields
</span>
<span class="n">ot_sampler</span> <span class="o">=</span> <span class="nc">OTPlanSampler</span><span class="p">()</span>
<span class="n">tmp0ot</span><span class="p">,</span> <span class="n">tmp1ot</span> <span class="o">=</span> <span class="n">ot_sampler</span><span class="p">.</span><span class="nf">sample_plan</span><span class="p">(</span><span class="n">tmp0</span><span class="p">,</span> <span class="n">tmp1</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">scatter</span><span class="p">(</span><span class="n">tmp0</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tmp0</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">p0</span><span class="sh">'</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">scatter</span><span class="p">(</span><span class="n">tmp1</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tmp1</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">p1</span><span class="sh">'</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">plot</span><span class="p">([</span><span class="n">tmp0</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tmp1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">tmp0</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">tmp1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">'</span><span class="s">Original</span><span class="sh">'</span><span class="p">)</span>
    
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">scatter</span><span class="p">(</span><span class="n">tmp0ot</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tmp0ot</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">p0</span><span class="sh">'</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">scatter</span><span class="p">(</span><span class="n">tmp1ot</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tmp1ot</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">p1</span><span class="sh">'</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">plot</span><span class="p">([</span><span class="n">tmp0ot</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tmp1ot</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">tmp0ot</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">tmp1ot</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">color</span><span class="o">=</span><span class="sh">'</span><span class="s">black</span><span class="sh">'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">set_title</span><span class="p">(</span><span class="sh">'</span><span class="s">OT</span><span class="sh">'</span><span class="p">)</span>
    
<span class="n">plt</span><span class="p">.</span><span class="nf">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/ot-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/ot-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/ot-1400.webp"></source> <img src="/assets/img/posts/cfm/ot.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <p>2-1. 8-Gaussian to Moon:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">cfm_wrapper</span><span class="p">(</span><span class="n">sample_8_gaussians</span><span class="p">,</span> <span class="n">sample_moons</span><span class="p">,</span> <span class="n">pt_sampler</span><span class="o">=</span><span class="n">sample_conditional_pt</span><span class="p">,</span> <span class="n">vector_field</span><span class="o">=</span><span class="n">conditional_vector_field</span><span class="p">,</span> <span class="n">ot_sampler</span><span class="o">=</span><span class="nc">OTPlanSampler</span><span class="p">(),</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="c1"># loss ~ 0.053
</span></code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig1-1s-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig1-1s-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig1-1s-1400.webp"></source> <img src="/assets/img/posts/cfm/fig1-1s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <p>2-2. Generating Moon</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">cfm_wrapper</span><span class="p">(</span><span class="n">sample_noise</span><span class="p">,</span> <span class="n">sample_moons</span><span class="p">,</span> <span class="n">pt_sampler</span><span class="o">=</span><span class="n">sample_conditional_pt</span><span class="p">,</span> <span class="n">vector_field</span><span class="o">=</span><span class="n">conditional_vector_field</span><span class="p">,</span> <span class="n">ot_sampler</span><span class="o">=</span><span class="nc">OTPlanSampler</span><span class="p">(),</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">likelihood</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># loss ~ 0.014
</span></code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig2-2s-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig2-2s-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig2-2s-1400.webp"></source> <img src="/assets/img/posts/cfm/fig2-2s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig2-2l-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig2-2l-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig2-2l-1400.webp"></source> <img src="/assets/img/posts/cfm/fig2-2l.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <p>2-3. Generating Checkerboard</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">cfm_wrapper</span><span class="p">(</span><span class="n">sample_noise</span><span class="p">,</span> <span class="n">sample_checkerboard_data</span><span class="p">,</span> <span class="n">pt_sampler</span><span class="o">=</span><span class="n">sample_conditional_pt</span><span class="p">,</span> <span class="n">vector_field</span><span class="o">=</span><span class="n">conditional_vector_field</span><span class="p">,</span> <span class="n">ot_sampler</span><span class="o">=</span><span class="nc">OTPlanSampler</span><span class="p">(),</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">likelihood</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># loss ~ 0.013
</span></code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig2-3s-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig2-3s-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig2-3s-1400.webp"></source> <img src="/assets/img/posts/cfm/fig2-3s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig2-3l-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig2-3l-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig2-3l-1400.webp"></source> <img src="/assets/img/posts/cfm/fig2-3l.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <p>2-4. Generating 8-Gaussians</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">cfm_wrapper</span><span class="p">(</span><span class="n">sample_noise</span><span class="p">,</span> <span class="n">sample_8_gaussians</span><span class="p">,</span> <span class="n">pt_sampler</span><span class="o">=</span><span class="n">sample_conditional_pt</span><span class="p">,</span> <span class="n">vector_field</span><span class="o">=</span><span class="n">conditional_vector_field</span><span class="p">,</span> <span class="n">ot_sampler</span><span class="o">=</span><span class="nc">OTPlanSampler</span><span class="p">(),</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">likelihood</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># loss ~ 0.020
</span></code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig2-4s-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig2-4s-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig2-4s-1400.webp"></source> <img src="/assets/img/posts/cfm/fig2-4s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig2-4l-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig2-4l-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig2-4l-1400.webp"></source> <img src="/assets/img/posts/cfm/fig2-4l.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <h4 id="3-schrodinger-bridge">3. Schrodinger Bridge</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Let's try using Schrodinger Bridge
</span>
<span class="c1"># for SB, We keep the mu as previous but change variance to be time-dependent: var = t(1-t)sigma^2
# this changes the flow vector field so we need to rewrite "sample_conditional_pt" and "conditional_vector_field" functions
</span>
<span class="k">def</span> <span class="nf">sample_conditional_pt_SB</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    
    <span class="sh">'''</span><span class="s">
    Draw a sample from N(mu_t(x0, x1), sigma), where
    mu_t(x0, x1) = t * x1 + (1 - t) * x0 being the interpolation between x0 and x1
    sigma_t^2 = t * (1-t) * sigma^2
    </span><span class="sh">'''</span>
    
    <span class="k">assert</span> <span class="n">x0</span><span class="p">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">x1</span><span class="p">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">t</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x0</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">]</span>
    <span class="n">mu_t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">x0</span>
    <span class="n">sigma_t</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>
    
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn_like</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mu_t</span> <span class="o">+</span> <span class="n">sigma_t</span> <span class="o">*</span> <span class="n">epsilon</span>

<span class="k">def</span> <span class="nf">conditional_vector_field_SB</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">xt</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">
    Compute the conditional vector fields u_t(x| x0, x1) = sigma_t</span><span class="sh">'</span><span class="s"> (x - mu_t) / sigma_t + mu_t</span><span class="sh">'</span><span class="s">
    Since sigma_t = sigma is a constant, sigma_t</span><span class="sh">'</span><span class="s"> = 0 in the above scenerio
    u_t(x| x0, x1) = mu_t</span><span class="sh">'</span><span class="s"> = x1 - x0
    </span><span class="sh">'''</span>
    
    <span class="k">assert</span> <span class="n">x0</span><span class="p">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">x1</span><span class="p">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">xt</span><span class="p">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">t</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x0</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">]</span>
    <span class="n">mu_t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">x0</span>
    <span class="n">sigma_t_prime_over_sigma_t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>
    <span class="n">ut</span> <span class="o">=</span> <span class="n">sigma_t_prime_over_sigma_t</span> <span class="o">*</span> <span class="p">(</span><span class="n">xt</span> <span class="o">-</span> <span class="n">mu_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span>

    <span class="k">return</span> <span class="n">ut</span>
</code></pre></div></div> <p><br></p> <p>3-1. 8-Gaussian to Moon:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">cfm_wrapper</span><span class="p">(</span><span class="n">sample_8_gaussians</span><span class="p">,</span> <span class="n">sample_moons</span><span class="p">,</span> <span class="n">pt_sampler</span><span class="o">=</span><span class="n">sample_conditional_pt_SB</span><span class="p">,</span> <span class="n">vector_field</span><span class="o">=</span><span class="n">conditional_vector_field_SB</span><span class="p">,</span> <span class="n">ot_sampler</span><span class="o">=</span><span class="nc">OTPlanSampler</span><span class="p">(),</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="c1"># loss ~ 0.044
</span></code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig3-1s-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig3-1s-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig3-1s-1400.webp"></source> <img src="/assets/img/posts/cfm/fig3-1s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <p>3-2. Generating Moon:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">cfm_wrapper</span><span class="p">(</span><span class="n">sample_noise</span><span class="p">,</span> <span class="n">sample_moons</span><span class="p">,</span> <span class="n">pt_sampler</span><span class="o">=</span><span class="n">sample_conditional_pt_SB</span><span class="p">,</span> <span class="n">vector_field</span><span class="o">=</span><span class="n">conditional_vector_field_SB</span><span class="p">,</span> <span class="n">ot_sampler</span><span class="o">=</span><span class="nc">OTPlanSampler</span><span class="p">(),</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">likelihood</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># loss ~ 0.012
</span></code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig3-2s-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig3-2s-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig3-2s-1400.webp"></source> <img src="/assets/img/posts/cfm/fig3-2s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig3-2l-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig3-2l-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig3-2l-1400.webp"></source> <img src="/assets/img/posts/cfm/fig3-2l.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <p>3-3. Generating Checkerboard</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">cfm_wrapper</span><span class="p">(</span><span class="n">sample_noise</span><span class="p">,</span> <span class="n">sample_checkerboard_data</span><span class="p">,</span> <span class="n">pt_sampler</span><span class="o">=</span><span class="n">sample_conditional_pt_SB</span><span class="p">,</span> <span class="n">vector_field</span><span class="o">=</span><span class="n">conditional_vector_field_SB</span><span class="p">,</span> <span class="n">ot_sampler</span><span class="o">=</span><span class="nc">OTPlanSampler</span><span class="p">(),</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">likelihood</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># loss ~ 0.011
</span></code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig3-3s-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig3-3s-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig3-3s-1400.webp"></source> <img src="/assets/img/posts/cfm/fig3-3s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig3-3l-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig3-3l-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig3-3l-1400.webp"></source> <img src="/assets/img/posts/cfm/fig3-3l.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <p>3.4 Generating 8-Gaussians</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">cfm_wrapper</span><span class="p">(</span><span class="n">sample_noise</span><span class="p">,</span> <span class="n">sample_8_gaussians</span><span class="p">,</span> <span class="n">pt_sampler</span><span class="o">=</span><span class="n">sample_conditional_pt_SB</span><span class="p">,</span> <span class="n">vector_field</span><span class="o">=</span><span class="n">conditional_vector_field_SB</span><span class="p">,</span> <span class="n">ot_sampler</span><span class="o">=</span><span class="nc">OTPlanSampler</span><span class="p">(),</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">likelihood</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="c1"># loss ~ 0.023
</span></code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig3-4s-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig3-4s-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig3-4s-1400.webp"></source> <img src="/assets/img/posts/cfm/fig3-4s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig3-4l-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig3-4l-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig3-4l-1400.webp"></source> <img src="/assets/img/posts/cfm/fig3-4l.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <p>So, we can see that OT improves the training with much smaller loss converged and the probability calculation stabilizes in 2 checkpoints (4000 epochs).</p> <h4 id="4-score--flow-matching-sf2m">4. Score + Flow Matching, SF2M</h4> <p>Here, we cannot use <code class="language-plaintext highlighter-rouge">cfm_wrapper</code> but the difference is minimal, just add a score matching term.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Let's try using SF2M: Score + Flow matching
</span>
<span class="kn">import</span> <span class="n">torchsde</span>

<span class="c1"># the pt and flow field are the same as the SB case but here we add a score model to fit the scores from pt
# additionally, we will need a lambda(t) for the score scaling
</span>
<span class="k">def</span> <span class="nf">sample_conditional_pt_SB_noise</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    
    <span class="sh">'''</span><span class="s">
    Draw a sample from N(mu_t(x0, x1), sigma), where
    mu_t(x0, x1) = t * x1 + (1 - t) * x0 being the interpolation between x0 and x1
    sigma_t^2 = t * (1-t) * sigma^2
    </span><span class="sh">'''</span>
    
    <span class="k">assert</span> <span class="n">x0</span><span class="p">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">x1</span><span class="p">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">t</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x0</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">]</span>
    <span class="n">mu_t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">x1</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">x0</span>
    <span class="n">sigma_t</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>
    
    <span class="n">epsilon</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">randn_like</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mu_t</span> <span class="o">+</span> <span class="n">sigma_t</span> <span class="o">*</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">epsilon</span>

<span class="c1"># lambda(t)
</span><span class="k">def</span> <span class="nf">lamb</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span> 
    
    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">]</span>
    <span class="n">sigma_t</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">torch</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">sigma_t</span> <span class="o">/</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>


<span class="c1"># wrap the flow and score in a module
</span><span class="k">class</span> <span class="nc">SDE</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span> 
    
    <span class="n">noise_type</span> <span class="o">=</span> <span class="sh">'</span><span class="s">diagonal</span><span class="sh">'</span>
    <span class="n">sde_type</span> <span class="o">=</span> <span class="sh">'</span><span class="s">ito</span><span class="sh">'</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">input_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span> 
        <span class="nf">super</span><span class="p">(</span><span class="n">SDE</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>
        <span class="n">self</span><span class="p">.</span><span class="n">flow</span> <span class="o">=</span> <span class="n">flow</span>
        <span class="n">self</span><span class="p">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">score</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_size</span> <span class="o">=</span> <span class="n">input_size</span>
        <span class="n">self</span><span class="p">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> 
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">self</span><span class="p">.</span><span class="n">input_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="nf">len</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">shape</span><span class="p">):</span> 
            <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="nf">repeat</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])[:,</span> <span class="bp">None</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">flow</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="nf">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">self</span><span class="p">.</span><span class="nf">score</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="nf">flatten</span><span class="p">(</span><span class="n">start_dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> 
        <span class="k">return</span> <span class="n">torch</span><span class="p">.</span><span class="nf">ones_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">self</span><span class="p">.</span><span class="n">sigma</span> <span class="o">*</span> <span class="mf">5.0</span> <span class="c1"># can be used to tune the noise, like diffusion
</span></code></pre></div></div> <p>And we construct a <code class="language-plaintext highlighter-rouge">SF2M</code> wrapper:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sf2m_wrapper</span><span class="p">(</span><span class="n">p0_sampler</span><span class="p">,</span> <span class="n">p1_sampler</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">1024</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">10000</span><span class="p">):</span> 

    <span class="c1"># Everything the same, just add score matching part
</span>    <span class="n">ot_sampler</span> <span class="o">=</span> <span class="nc">OTPlanSampler</span><span class="p">()</span>

    <span class="c1"># some parameters
</span>    <span class="n">sigma</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1"># sigma_t = sigma = 0.1 a small constant value
</span>    <span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">n_checkpoints</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="n">model</span> <span class="o">=</span> <span class="nc">MLP</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">time_varying</span><span class="o">=</span><span class="bp">True</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>
    <span class="n">score_model</span> <span class="o">=</span> <span class="nc">MLP</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">time_varying</span><span class="o">=</span><span class="bp">True</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>
    
    <span class="c1"># using both model weights, equivalent to training them individually
</span>    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="n">optim</span><span class="p">.</span><span class="nc">AdamW</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">())</span> <span class="o">+</span> <span class="nf">list</span><span class="p">(</span><span class="n">score_model</span><span class="p">.</span><span class="nf">parameters</span><span class="p">()))</span> 

    <span class="n">flow_checkpoints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">score_checkpoints</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">pbar</span> <span class="o">=</span> <span class="nf">tqdm</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">n_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pbar</span><span class="p">:</span> 

        <span class="c1"># sample prior = gaussian, posterior = moons
</span>        <span class="n">x0</span> <span class="o">=</span> <span class="nf">p0_sampler</span><span class="p">(</span><span class="n">batch_size</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="nf">p1_sampler</span><span class="p">(</span><span class="n">batch_size</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>

        <span class="c1"># match rows using OT plan
</span>        <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">ot_sampler</span><span class="p">.</span><span class="nf">sample_plan</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>

        <span class="c1"># sample time
</span>        <span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">rand</span><span class="p">(</span><span class="n">x0</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x0</span><span class="p">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">DEVICE</span><span class="p">)</span>

        <span class="c1"># generate some noisy x_t in between 
</span>        <span class="n">xt</span><span class="p">,</span> <span class="n">ep</span> <span class="o">=</span> <span class="nf">sample_conditional_pt_SB_noise</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>

        <span class="c1"># conditional flow vector field
</span>        <span class="n">ut</span> <span class="o">=</span> <span class="nf">conditional_vector_field_SB</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">xt</span><span class="p">)</span>

        <span class="c1"># the model input is the noisy point xt and time 
</span>        <span class="c1"># the model output is the flow to matching that of ut
</span>        <span class="n">vt</span> <span class="o">=</span> <span class="nf">model</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">xt</span><span class="p">,</span> <span class="n">t</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">st</span> <span class="o">=</span> <span class="nf">score_model</span><span class="p">(</span><span class="n">torch</span><span class="p">.</span><span class="nf">cat</span><span class="p">([</span><span class="n">xt</span><span class="p">,</span> <span class="n">t</span><span class="p">[...,</span> <span class="bp">None</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># score
</span>
        <span class="c1"># loss is the flow matching loss
</span>        <span class="n">flow_loss</span> <span class="o">=</span> <span class="p">((</span><span class="n">vt</span> <span class="o">-</span> <span class="n">ut</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">).</span><span class="nf">mean</span><span class="p">()</span>
        <span class="n">score_loss</span> <span class="o">=</span> <span class="p">((</span><span class="nf">lamb</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">st</span> <span class="o">+</span> <span class="n">ep</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">).</span><span class="nf">mean</span><span class="p">()</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">flow_loss</span> <span class="o">+</span> <span class="n">score_loss</span>

        <span class="c1"># normal pytorch stuff
</span>        <span class="n">optimizer</span><span class="p">.</span><span class="nf">zero_grad</span><span class="p">()</span>
        <span class="n">loss</span><span class="p">.</span><span class="nf">backward</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="p">.</span><span class="nf">step</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">pbar</span><span class="p">.</span><span class="nf">set_description</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">Training step </span><span class="si">{</span><span class="n">k</span><span class="si">:</span><span class="mi">06</span><span class="n">d</span><span class="si">}</span><span class="s">, loss = </span><span class="si">{</span><span class="n">loss</span><span class="p">.</span><span class="nf">item</span><span class="p">()</span><span class="si">:</span><span class="p">.</span><span class="mi">3</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
        <span class="nf">if </span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">k</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_steps</span> <span class="o">//</span> <span class="n">n_checkpoints</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span> 
            <span class="n">flow_checkpoints</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">copy</span><span class="p">.</span><span class="nf">deepcopy</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>
            <span class="n">score_checkpoints</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">copy</span><span class="p">.</span><span class="nf">deepcopy</span><span class="p">(</span><span class="n">score_model</span><span class="p">))</span>


    <span class="c1">## sample using the flow model only: 
</span>    <span class="n">prior_samples</span> <span class="o">=</span> <span class="nf">p0_sampler</span><span class="p">(</span><span class="mi">1024</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="n">DEVICE</span><span class="p">)</span>
    <span class="n">trajs</span> <span class="o">=</span> <span class="nf">sampling</span><span class="p">(</span><span class="n">prior_samples</span><span class="p">,</span> <span class="n">flow_checkpoints</span><span class="p">)</span>
    <span class="nf">plot_trajs</span><span class="p">(</span><span class="n">trajs</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="n">n_steps</span><span class="p">)</span>

    <span class="c1">## Sample using flow + score models
</span>    <span class="n">trajs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">flow_checkpoint</span><span class="p">,</span> <span class="n">score_checkpoint</span> <span class="ow">in</span> <span class="nf">tqdm</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">flow_checkpoints</span><span class="p">,</span> <span class="n">score_checkpoints</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="sh">'</span><span class="s">sample from checkpoint</span><span class="sh">'</span><span class="p">):</span>

        <span class="n">sde</span> <span class="o">=</span> <span class="nc">SDE</span><span class="p">(</span><span class="n">flow_checkpoint</span><span class="p">,</span> <span class="n">score_checkpoint</span><span class="p">,</span> <span class="n">input_size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,),</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">torch</span><span class="p">.</span><span class="nf">no_grad</span><span class="p">():</span>
            <span class="n">ts</span> <span class="o">=</span> <span class="n">torch</span><span class="p">.</span><span class="nf">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">DEVICE</span><span class="p">)</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="n">torchsde</span><span class="p">.</span><span class="nf">sdeint</span><span class="p">(</span><span class="n">sde</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">ts</span><span class="o">=</span><span class="n">ts</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="sh">'</span><span class="s">srk</span><span class="sh">'</span><span class="p">)</span>
            <span class="n">trajs</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">traj</span><span class="p">.</span><span class="nf">cpu</span><span class="p">().</span><span class="nf">numpy</span><span class="p">())</span>

    <span class="nf">plot_trajs</span><span class="p">(</span><span class="n">trajs</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="n">n_steps</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div> <p><br></p> <p>4-1. 8-Gaussian to Moon</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sf2m_wrapper</span><span class="p">(</span><span class="n">sample_8_gaussians</span><span class="p">,</span> <span class="n">sample_moons</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="c1"># loss ~ 1.074
</span></code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig4-1s-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig4-1s-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig4-1s-1400.webp"></source> <img src="/assets/img/posts/cfm/fig4-1s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig4-1ss-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig4-1ss-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig4-1ss-1400.webp"></source> <img src="/assets/img/posts/cfm/fig4-1ss.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <p>4-2. Generating Moon</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sf2m_wrapper</span><span class="p">(</span><span class="n">sample_noise</span><span class="p">,</span> <span class="n">sample_moons</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="c1"># loss ~ 1.037
</span></code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig4-2s-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig4-2s-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig4-2s-1400.webp"></source> <img src="/assets/img/posts/cfm/fig4-2s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig4-2ss-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig4-2ss-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig4-2ss-1400.webp"></source> <img src="/assets/img/posts/cfm/fig4-2ss.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <p>4-3. Generating Checkerboard</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sf2m_wrapper</span><span class="p">(</span><span class="n">sample_noise</span><span class="p">,</span> <span class="n">sample_checkerboard_data</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="c1"># loss ~ 1.031
</span></code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig4-3s-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig4-3s-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig4-3s-1400.webp"></source> <img src="/assets/img/posts/cfm/fig4-3s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig4-3ss-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig4-3ss-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig4-3ss-1400.webp"></source> <img src="/assets/img/posts/cfm/fig4-3ss.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <p>4-4. Generating 8-Gaussians</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">sf2m_wrapper</span><span class="p">(</span><span class="n">sample_noise</span><span class="p">,</span> <span class="n">sample_8_gaussians</span><span class="p">,</span> <span class="n">n_steps</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="c1"># loss ~ 1.051
</span></code></pre></div></div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig4-4s-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig4-4s-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig4-4s-1400.webp"></source> <img src="/assets/img/posts/cfm/fig4-4s.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/posts/cfm/fig4-4ss-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/posts/cfm/fig4-4ss-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/posts/cfm/fig4-4ss-1400.webp"></source> <img src="/assets/img/posts/cfm/fig4-4ss.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <p><br></p> <p>This gets a bit longer that expected. The image case will be in a separate post.</p> <h3 id="references">References</h3> <ol> <li>Lipman et al, Flow Matching for Generative Modeling, (<a href="https://arxiv.org/abs/2210.02747" rel="external nofollow noopener" target="_blank">link</a>)</li> <li>Lipman et al, Flow Matching Guide and Code, (<a href="https://arxiv.org/abs/2412.06264" rel="external nofollow noopener" target="_blank">link</a>)</li> <li>Tong et al, Improving and generalizing flow-based generative models with minibatch optimal transport (<a href="https://arxiv.org/abs/2302.00482" rel="external nofollow noopener" target="_blank">link</a>)</li> <li>Tong et al, Simulation-free Schrodinger bridges via score and flow matching (<a href="https://arxiv.org/abs/2307.03672" rel="external nofollow noopener" target="_blank">link</a>)</li> <li><a href="https://github.com/atong01/conditional-flow-matching?tab=readme-ov-file" rel="external nofollow noopener" target="_blank">TorchCFM</a></li> <li><a href="https://github.com/facebookresearch/flow_matching" rel="external nofollow noopener" target="_blank">Flow-Matching</a></li> </ol> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Yen-Lin Chen. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: June 27, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>